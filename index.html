<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daniels tidslinje-mekker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Library for reading/writing JPEG metadata -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/piexifjs/1.0.6/piexif.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        canvas {
            cursor: grab;
        }
        canvas.grabbing {
            cursor: grabbing;
        }
        .modal {
            display: none; /* Hidden by default */
        }
        .modal.active {
            display: flex; /* Show when active */
        }
        /* Custom styles for range slider */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db; /* gray-300 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5; /* indigo-600 */
            cursor: pointer;
            border-radius: 50%;
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5; /* indigo-600 */
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="color"] {
        	-webkit-appearance: none;
        	border: none;
        	width: 40px;
        	height: 40px;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
        	padding: 0;
            border-radius: 50%;
        }
        input[type="color"]::-webkit-color-swatch {
        	border: 1px solid #e2e8f0;
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen overflow-hidden">

    <!-- Header & Controls -->
    <header class="bg-white shadow-md p-2 md:p-4 flex flex-wrap items-center justify-between gap-4 z-10">
        <h1 class="text-xl md:text-2xl font-bold text-gray-700 flex items-center gap-2">
            <img src="https://placehold.co/40x40/6366f1/ffffff?text=DT" alt="Timeline Logo" class="w-7 h-7 rounded-full object-cover">
            Daniels tidslinje-mekker
        </h1>
        
        <div class="flex items-center gap-4 flex-wrap">
            <!-- Date Range Display -->
            <div class="flex items-center gap-2 flex-wrap">
                <label for="startDate" class="text-sm font-medium">Fra år...</label>
                <input type="number" id="startDate" value="-2000" class="w-24 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                <label for="endDate" class="text-sm font-medium">...til år.</label>
                <input type="number" id="endDate" value="2026" class="w-24 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                <button id="setDateRangeBtn" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-sm font-semibold">Sett tidsrom</button>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex items-center gap-2 flex-wrap">
            <button id="addEventBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 text-sm font-semibold">Legg til hendelse</button>
            <button id="addPeriodBtn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 text-sm font-semibold">Legg til periode</button>
            <button id="exportBtn" class="px-4 py-2 bg-gray-700 text-white rounded-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-600 text-sm font-semibold">Eksporter</button>
            <button id="importBtn" class="px-4 py-2 bg-gray-700 text-white rounded-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-600 text-sm font-semibold">Importer</button>
            <button id="clearAllBtn" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 text-sm font-semibold">Slett alt</button>
            <input type="file" id="importFile" class="hidden" accept=".json,image/jpeg">
        </div>
    </header>

    <!-- Main Content: Canvas -->
    <main class="flex-grow relative">
        <canvas id="timelineCanvas"></canvas>
        
        <!-- IMPROVED: Mini Navigator -->
        <div id="miniNavigator" class="absolute top-4 right-4 bg-white bg-opacity-90 backdrop-blur-sm p-2 rounded-lg shadow-lg z-20 w-64 flex flex-col gap-2">
             <div class="flex items-center gap-2">
                <label for="jumpToYear" class="text-xs font-medium whitespace-nowrap">Gå til:</label>
                <input type="number" id="jumpToYear" class="w-full p-1 border border-gray-300 rounded-md shadow-sm text-xs">
                <button id="jumpToYearBtn" class="px-3 py-1 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 text-xs font-semibold">Gå</button>
            </div>
            <canvas id="miniCanvas" class="w-full h-16 rounded cursor-pointer border border-gray-200"></canvas>
        </div>

        <!-- Bottom Controls -->
        <div class="absolute bottom-4 left-1/2 -translate-x-1/2 bg-white bg-opacity-80 backdrop-blur-sm p-3 rounded-lg shadow-lg z-20 flex items-center gap-6 opacity-70 hover:opacity-100 transition-opacity duration-300">
            <!-- Zoom Level -->
            <div class="flex items-center gap-2">
                <label for="zoomLevel" class="text-sm font-medium">Zoom</label>
                <input type="range" id="zoomLevel" min="0" max="100" value="0" class="w-48">
            </div>

            <!-- Detail Level -->
            <div class="flex items-center gap-2">
                <label for="zoomSensitivity" class="text-sm font-medium">Detaljnivå</label>
                <input type="range" id="zoomSensitivity" min="0.5" max="5" step="0.1" value="3.875" class="w-48">
            </div>

            <!-- Show Descriptions Toggle -->
            <div class="flex items-center gap-2 pl-4 border-l">
                <label for="showDescriptionsToggle" class="text-sm font-medium cursor-pointer">Vis beskrivelser</label>
                <input type="checkbox" id="showDescriptionsToggle" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 cursor-pointer">
            </div>
        </div>
    </main>

    <!-- Modals -->
    <!-- Details Modal -->
    <div id="detailsModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 items-center justify-center z-30">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg m-4 max-h-[90vh] overflow-y-auto">
            <h2 id="detailsTitle" class="text-2xl font-bold mb-4 text-gray-800"></h2>
            <p id="detailsDesc" class="text-gray-600 mb-4 whitespace-pre-wrap"></p>
            <img id="detailsImg" src="" alt="Image preview" class="hidden max-w-full max-h-[50vh] mx-auto rounded-md mb-4 object-contain" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" >
            <p id="detailsImgError" class="text-center text-red-500 hidden">Bilde kunne ikke lastes.</p>
            <div class="flex justify-between items-center">
                <div>
                    <button type="button" id="editItemBtn" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Rediger</button>
                    <button type="button" id="deleteItemBtn" class="px-4 py-2 ml-2 bg-red-600 text-white rounded-md hover:bg-red-700">Slett</button>
                </div>
                <button type="button" id="closeDetails" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Lukk</button>
            </div>
        </div>
    </div>
    
    <!-- Event Modal -->
    <div id="eventModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 items-center justify-center z-40">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md m-4 max-h-[90vh] overflow-y-auto">
            <h2 id="eventModalTitle" class="text-2xl font-bold mb-4">Legg til ny hendelse</h2>
            <form id="eventForm">
                <input type="hidden" id="eventId">
                <div class="mb-4">
                    <label for="eventDate" class="block text-sm font-medium text-gray-700">Dato (År)</label>
                    <input type="number" step="any" id="eventDate" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="mb-4">
                    <label for="eventTitle" class="block text-sm font-medium text-gray-700">Tittel</label>
                    <input type="text" id="eventTitle" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="mb-4">
                    <label for="eventDesc" class="block text-sm font-medium text-gray-700">Beskrivelse</label>
                    <textarea id="eventDesc" rows="3" maxlength="120" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                    <div id="eventCharCount" class="text-right text-sm text-gray-500 mt-1">0 / 120</div>
                </div>
                <div class="flex gap-4">
                    <div class="mb-4 flex-grow">
                        <label for="eventImg" class="block text-sm font-medium text-gray-700">Bilde-URL (Valgfritt)</label>
                        <input type="url" id="eventImg" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div class="mb-4">
                        <label for="eventColor" class="block text-sm font-medium text-gray-700 text-center">Farge</label>
                        <input type="color" id="eventColor" value="#38A169" class="mt-1">
                    </div>
                </div>
                <div class="flex justify-end gap-4">
                    <button type="button" id="cancelEvent" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Avbryt</button>
                    <button type="submit" id="saveEventBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Legg til hendelse</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Period Modal -->
    <div id="periodModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 items-center justify-center z-40">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md m-4 max-h-[90vh] overflow-y-auto">
            <h2 id="periodModalTitle" class="text-2xl font-bold mb-4">Legg til ny periode</h2>
            <form id="periodForm">
                <input type="hidden" id="periodId">
                <div class="mb-4">
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="periodStartDate" class="block text-sm font-medium text-gray-700">Startdato (År)</label>
                            <input type="number" step="any" id="periodStartDate" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div>
                            <label for="periodEndDate" class="block text-sm font-medium text-gray-700">Sluttdato (År)</label>
                            <input type="number" step="any" id="periodEndDate" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                    </div>
                    <div class="mt-2">
                        <label class="flex items-center cursor-pointer">
                            <input type="checkbox" id="periodIsApproximate" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                            <span class="ml-2 text-sm text-gray-700">"Sånn ca." dato</span>
                        </label>
                    </div>
                </div>
                <div class="mb-4">
                    <label for="periodTitle" class="block text-sm font-medium text-gray-700">Tittel</label>
                    <input type="text" id="periodTitle" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="mb-4">
                    <label for="periodDesc" class="block text-sm font-medium text-gray-700">Beskrivelse</label>
                    <textarea id="periodDesc" rows="3" maxlength="120" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                    <div id="periodCharCount" class="text-right text-sm text-gray-500 mt-1">0 / 120</div>
                </div>
                 <div class="flex gap-4">
                    <div class="mb-4 flex-grow">
                        <label for="periodImg" class="block text-sm font-medium text-gray-700">Bilde-URL (Valgfritt)</label>
                        <input type="url" id="periodImg" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div class="mb-4">
                        <label for="periodColor" class="block text-sm font-medium text-gray-700 text-center">Farge</label>
                        <input type="color" id="periodColor" value="#4299E1" class="mt-1">
                    </div>
                </div>
                <div class="flex justify-end gap-4">
                    <button type="button" id="cancelPeriod" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Avbryt</button>
                    <button type="submit" id="savePeriodBtn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Legg til periode</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Export Modal -->
    <div id="exportModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 items-center justify-center z-20">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md m-4 max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-bold mb-4">Eksporter tidslinje</h2>
            <p class="text-gray-600 mb-6">Velg eksportformat.</p>
            <div class="flex flex-col gap-4">
                <button id="exportJpegAutoBtn" class="w-full px-4 py-3 bg-teal-500 text-white rounded-md hover:bg-teal-600 font-semibold">Last ned bilde (Auto)</button>
                <button id="exportJpegSettingsBtn" class="w-full px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 font-semibold text-sm">Manuelle innstillinger for bilde...</button>
            </div>
             <div class="mt-6 text-right">
                <button type="button" id="cancelExport" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Lukk</button>
            </div>
        </div>
    </div>

    <!-- Export JPEG Settings Modal -->
    <div id="exportJpegSettingsModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 items-center justify-center z-30">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg m-4 max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-bold mb-4">Innstillinger for bildeeksport</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="exportStartDate" class="block text-sm font-medium text-gray-700">Startår</label>
                    <input type="number" id="exportStartDate" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div>
                    <label for="exportEndDate" class="block text-sm font-medium text-gray-700">Sluttår</label>
                    <input type="number" id="exportEndDate" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div>
                    <label for="exportWidth" class="block text-sm font-medium text-gray-700">Bredde (piksler)</label>
                    <input type="number" id="exportWidth" value="1920" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div>
                    <label for="exportHeight" class="block text-sm font-medium text-gray-700">Høyde (piksler)</label>
                    <input type="number" id="exportHeight" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    <p class="text-xs text-gray-500 mt-1">Automatisk beregnet. Kan overstyres.</p>
                </div>
            </div>
            <div class="mb-4">
                <label class="flex items-center">
                    <input type="checkbox" id="exportDescriptions" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                    <span class="ml-2 text-sm text-gray-700">Vis beskrivelser</span>
                </label>
            </div>
            <div id="exportSpinner" class="hidden my-4 text-center">
                <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                <p class="text-sm text-gray-600">Genererer bilde...</p>
            </div>
            <div class="flex justify-end gap-4 mt-6">
                <button type="button" id="cancelExportJpeg" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Avbryt</button>
                <button type="button" id="generateJpegBtn" class="px-4 py-2 bg-teal-500 text-white rounded-md hover:bg-teal-600 font-semibold">Generer og last ned</button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm m-4">
            <h2 id="confirmTitle" class="text-lg font-bold mb-4">Er du sikker?</h2>
            <p id="confirmText" class="text-gray-600 mb-6">Denne handlingen kan ikke angres.</p>
            <div class="flex justify-end gap-4">
                <button type="button" id="confirmCancel" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Avbryt</button>
                <button type="button" id="confirmOk" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">Slett</button>
            </div>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const canvas = document.getElementById('timelineCanvas');
        const ctx = canvas.getContext('2d');
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        const setDateRangeBtn = document.getElementById('setDateRangeBtn');
        const zoomSensitivitySlider = document.getElementById('zoomSensitivity');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const showDescriptionsToggle = document.getElementById('showDescriptionsToggle');
        const zoomLevelSlider = document.getElementById('zoomLevel');
        
        // --- Mini Navigator Elements ---
        const miniCanvas = document.getElementById('miniCanvas');
        const miniCtx = miniCanvas.getContext('2d');
        const jumpToYearInput = document.getElementById('jumpToYear');
        const jumpToYearBtn = document.getElementById('jumpToYearBtn');

        // Modals
        const detailsModal = document.getElementById('detailsModal');
        const eventModal = document.getElementById('eventModal');
        const periodModal = document.getElementById('periodModal');
        const exportModal = document.getElementById('exportModal');
        const exportJpegSettingsModal = document.getElementById('exportJpegSettingsModal');
        const confirmModal = document.getElementById('confirmModal');

        // Buttons
        const addEventBtn = document.getElementById('addEventBtn');
        const addPeriodBtn = document.getElementById('addPeriodBtn');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const importFileInput = document.getElementById('importFile');
        
        let MIN_ZOOM_LEVEL = null;
        const MASTER_TIMELINE_START = -2000;
        const MASTER_TIMELINE_END = 2026;
        const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"];
        const MONTH_ZOOM_THRESHOLD = 200; // Pixels per year to show months

        // --- State Management ---
        let state = {
            events: [],
            periods: [],
            view: {
                start: MASTER_TIMELINE_START,
                end: MASTER_TIMELINE_END,
                zoom: 1, // pixels per year
                panX: 0,
                panY: 0,
                markerDensity: 3.875,
                showDescriptions: false,
                edgeIndicators: {
                    leftAnim: 0, // 0 (hidden) to 1 (visible)
                    rightAnim: 0,
                }
            },
            images: {}, // Cache for loaded images
            dragging: {
                isDown: false,
                startX: 0, // For panning and click-vs-drag check
                startY: 0,
                lastX: 0, // For calculating deltas when moving items
                lastY: 0,
                scrollLeft: 0,
                scrollTop: 0,
                activeItem: null, // Can be an event or a period
                dragType: null, // 'move', 'resize-left', 'resize-right', 'pan', 'create'
                creationRect: null, // For drag-to-create-period
                targetPeriod: null, // For reordering
            },
            miniNavDragging: false,
            mouse: {
                x: 0,
                y: 0,
                isOverItem: false,
                hoverDetail: null, // For showing extra info on hover, like year
            },
            editingItemId: null,
            editingItemType: null,
        };

        // --- Local Storage Management ---
        const LOCAL_STORAGE_KEY = 'timelineData';
        const saveState = () => {
            const dataToSave = {
                events: state.events.map(({lane, y, height, descriptionLines, ...rest}) => rest),
                periods: state.periods.map(({lane, y, height, descriptionLines, ...rest}) => rest),
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
            console.log('Tidslinje lagret automatisk.');
        };

        const loadState = () => {
            const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    state.events = parsedData.events || [];
                    state.periods = parsedData.periods || [];
                    [...state.events, ...state.periods].forEach(loadImage);
                    console.log('Tidslinje lastet fra lagring.');
                    return true;
                } catch (e) {
                    console.error("Feil ved lasting av lagret data:", e);
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    return false;
                }
            }
            return false;
        };

        // --- Canvas & Drawing Setup ---
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth * window.devicePixelRatio;
            canvas.height = canvas.parentElement.clientHeight * window.devicePixelRatio;
            canvas.style.width = `${canvas.parentElement.clientWidth}px`;
            canvas.style.height = `${canvas.parentElement.clientHeight}px`;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            resizeMiniCanvas();
            requestDraw();
        }

        function resizeMiniCanvas() {
            miniCanvas.width = miniCanvas.clientWidth * window.devicePixelRatio;
            miniCanvas.height = miniCanvas.clientHeight * window.devicePixelRatio;
            miniCanvas.style.width = `${miniCanvas.clientWidth}px`;
            miniCanvas.style.height = `${miniCanvas.clientHeight}px`;
            miniCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
        }

        // --- Coordinate Conversion & Clamping ---
        const dateToPx = (date) => (date - state.view.start) * state.view.zoom + state.view.panX;
        const pxToDate = (px) => (px - state.view.panX) / state.view.zoom + state.view.start;

        function clampPanX() {
            const dpr = window.devicePixelRatio || 1;
            const canvasWidth = canvas.width / dpr;
            const timelinePixelWidth = (state.view.end - state.view.start) * state.view.zoom;

            const minPanX = canvasWidth - timelinePixelWidth;
            const maxPanX = 0;
            
            if (timelinePixelWidth < canvasWidth) {
                 state.view.panX = (canvasWidth - timelinePixelWidth) / 2;
            } else {
                 state.view.panX = Math.max(minPanX, Math.min(state.view.panX, maxPanX));
            }
        }

        // --- Layout & Drawing ---
        let drawQueued = false;
        function requestDraw() {
            if (!drawQueued) {
                drawQueued = true;
                requestAnimationFrame(() => {
                    const dpr = window.devicePixelRatio || 1;
                    const viewHeight = canvas.height / dpr;
                    updateAnimations();
                    calculateLayout(dateToPx, viewHeight, state.view.panY);
                    draw();
                    drawMiniNavigator();
                    drawQueued = false;
                });
            }
        }

        function easeOutCubic(t) {
            return (--t) * t * t + 1;
        }

        function updateAnimations() {
            const dpr = window.devicePixelRatio || 1;
            const canvasWidth = canvas.width / dpr;
            const animSpeed = 0.05;

            // --- IMPROVEMENT: Edge indicator sensitivity reduced ---
            const masterStartX = dateToPx(MASTER_TIMELINE_START);
            const masterEndX = dateToPx(MASTER_TIMELINE_END);
            const sensitivity = 50; // Reduced from 200

            const showLeft = masterStartX >= -sensitivity;
            const showRight = masterEndX <= canvasWidth + sensitivity;
            
            if (showLeft) {
                state.view.edgeIndicators.leftAnim = Math.min(1, state.view.edgeIndicators.leftAnim + animSpeed);
            } else {
                state.view.edgeIndicators.leftAnim = Math.max(0, state.view.edgeIndicators.leftAnim - animSpeed);
            }

            if (showRight) {
                state.view.edgeIndicators.rightAnim = Math.min(1, state.view.edgeIndicators.rightAnim + animSpeed);
            } else {
                state.view.edgeIndicators.rightAnim = Math.max(0, state.view.edgeIndicators.rightAnim - animSpeed);
            }
            
            if ((state.view.edgeIndicators.leftAnim > 0 && state.view.edgeIndicators.leftAnim < 1) ||
                (state.view.edgeIndicators.rightAnim > 0 && state.view.edgeIndicators.rightAnim < 1)) {
                requestDraw();
            }
        }

        function getDynamicFontSize(lineCount) {
            const baseSize = 12;
            const minSize = 6;
            const maxLines = 10;
            const scaleThreshold = 20;

            if (lineCount <= maxLines) return baseSize;
            
            const scale = Math.max(0, (scaleThreshold - lineCount) / (scaleThreshold - maxLines));
            return minSize + (baseSize - minSize) * scale;
        }
        
        function calculateLayout(coordFn, viewHeight, panY, context = ctx) {
            const vSpacing = 15;
            const skylineUp = []; 
            const lanesDown = [];

            const sortedEvents = [...state.events].sort((a, b) => a.date - b.date);
            sortedEvents.forEach(event => {
                const eventX = coordFn(event.date);
                const boxWidth = 180;
                const startX = eventX - boxWidth / 2;
                const endX = eventX + boxWidth / 2;

                let lowestY = (viewHeight / 2) + panY - 30;
                for (const segment of skylineUp) {
                    if (Math.max(startX, segment.startX) < Math.min(endX, segment.endX)) {
                        lowestY = Math.min(lowestY, segment.topY);
                    }
                }
                
                let boxHeight = 0;
                if (state.view.showDescriptions && (event.description || event.img)) {
                    const titleHeight = 20; const padding = 10; let descHeight = 0; let imgHeight = 0;
                    if (event.description) {
                        const lines = wrapText(context, event.description, boxWidth - padding * 2);
                        event.descriptionLines = lines;
                        const fontSize = getDynamicFontSize(lines.length);
                        const lineHeight = fontSize * 1.2;
                        descHeight = lines.length * lineHeight;
                    } else {
                        event.descriptionLines = [];
                    }
                    if (event.img) imgHeight = 50 + (event.description ? padding : 0);
                    boxHeight = titleHeight + descHeight + imgHeight + padding * 2;
                }
                event.height = boxHeight;
                event.y = lowestY - (boxHeight > 0 ? boxHeight + vSpacing : 0);
                
                const newTopY = event.y - vSpacing;
                
                const newSkyline = [];
                let added = false;
                for (const segment of skylineUp) {
                    if (segment.endX <= startX) newSkyline.push(segment);
                    else {
                        if (!added) { newSkyline.push({ startX: startX, endX: endX, topY: newTopY }); added = true; }
                        if (segment.endX > endX) newSkyline.push({startX: endX, endX: segment.endX, topY: segment.topY});
                    }
                }
                if (!added) newSkyline.push({ startX: startX, endX: endX, topY: newTopY });
                skylineUp.length = 0;
                Array.prototype.push.apply(skylineUp, newSkyline.sort((a, b) => a.startX - b.startX));
            });

            const sortedPeriods = [...state.periods].sort((a, b) => (a.renderOrder || 0) - (b.renderOrder || 0));
            
            const lanes = [];
            
            sortedPeriods.forEach(period => {
                const startX = coordFn(period.startDate);
                const endX = coordFn(period.endDate);
                
                const titleHeight = 16; const paddingY = 4; let descriptionHeight = 0; let imageHeight = 0;
                const yearRangeHeight = 10;
                
                if (state.view.showDescriptions && period.description) {
                    const width = endX - startX;
                    const wrapWidth = Math.max(1, width - (paddingY * 2));
                    const lines = wrapText(context, period.description, wrapWidth);
                    period.descriptionLines = lines;
                    const fontSize = getDynamicFontSize(lines.length);
                    const lineHeight = fontSize * 1.2;
                    descriptionHeight = lines.length * lineHeight;
                } else {
                    period.descriptionLines = [];
                }

                if (state.view.showDescriptions && period.img) {
                    imageHeight = 50 + (period.description ? paddingY : 0);
                }

                period.height = titleHeight + yearRangeHeight + descriptionHeight + imageHeight + (paddingY * 2);

                let assignedLaneIndex = -1;
                for (let i = 0; i < lanes.length; i++) {
                    const lane = lanes[i];
                    let overlaps = false;
                    for (const p of lane) {
                        if (Math.max(startX, coordFn(p.startDate)) < Math.min(endX, coordFn(p.endDate))) {
                            overlaps = true;
                            break;
                        }
                    }
                    if (!overlaps) {
                        assignedLaneIndex = i;
                        break;
                    }
                }

                if (assignedLaneIndex === -1) {
                    assignedLaneIndex = lanes.length;
                    lanes.push([]);
                }
                
                lanes[assignedLaneIndex].push(period);
            });

            const laneHeights = lanes.map(lane => {
                if (lane.length === 0) return 0;
                return Math.max(...lane.map(p => p.height));
            });
            
            let currentY = (viewHeight / 2) + panY + 30;
            for (let i = 0; i < lanes.length; i++) {
                const laneHeight = laneHeights[i];
                for (const period of lanes[i]) {
                    period.y = currentY;
                    period.height = laneHeight; 
                }
                currentY += laneHeight;
            }
        }

        function drawHoverYearIndicator() {
            if (!state.mouse.hoverDetail || (state.dragging.isDown && state.dragging.dragType !== 'create')) return;

            const detail = state.mouse.hoverDetail;
            if (detail.type === 'period-edge') {
                const period = detail.item;
                const year = detail.side === 'left' ? period.startDate : period.endDate;
                const text = formatYear(year);
                const x = detail.side === 'left' ? dateToPx(period.startDate) : dateToPx(period.endDate);
                const y = period.y - 12;

                ctx.save();
                ctx.font = 'bold 12px Inter';
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width;
                const textHeight = 12;
                const padding = 6;

                ctx.fillStyle = 'rgba(45, 55, 72, 0.85)';
                ctx.beginPath();
                ctx.roundRect(x - textWidth / 2 - padding, y - textHeight / 2 - padding, textWidth + padding * 2, textHeight + padding * 2, 4);
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, x, y);
                ctx.restore();
            }
        }

        function draw() {
            const dpr = window.devicePixelRatio || 1;
            const { width, height } = canvas;
            ctx.clearRect(0, 0, width / dpr, height / dpr);

            const axisY = (height / dpr / 2) + state.view.panY;
            ctx.beginPath();
            ctx.moveTo(0, axisY);
            ctx.lineTo(width / dpr, axisY);
            ctx.strokeStyle = '#4A5568';
            ctx.lineWidth = 2;
            ctx.stroke();

            drawMarkers(axisY);
            drawPeriods(ctx, dateToPx, state.periods, state.images, state.view.showDescriptions);
            drawEvents(ctx, dateToPx, state.events, state.images, axisY, state.view.showDescriptions);
            drawCreationRect();
            drawHoverIndicator();
            drawHoverYearIndicator();
            drawEdgeIndicators();
        }

        function drawEdgeIndicators() {
            const dpr = window.devicePixelRatio || 1;
            const canvasWidth = canvas.width / dpr;
            const animLeft = easeOutCubic(state.view.edgeIndicators.leftAnim);
            const animRight = easeOutCubic(state.view.edgeIndicators.rightAnim);

            ctx.save();
            ctx.fillStyle = 'rgba(113, 128, 150, 0.8)';
            ctx.strokeStyle = 'rgba(113, 128, 150, 0.8)';
            ctx.lineWidth = 1.5;

            if (animLeft > 0) {
                const leftTexts = [
                    { title: "Universet oppstår", date: "(ca. 13.8 mrd. år fvt.)" },
                    { title: "Jorda oppstår", date: "(ca. 4.5 mrd. år fvt.)" },
                    { title: "Liv oppstår", date: "(ca. 3.7 mrd. år fvt.)" },
                    { title: "Pattedyr oppstår", date: "(ca. 225 mill. år fvt.)" },
                    { title: "Homo Sapiens oppstår", date: "(ca. 300 000 år fvt.)" },
                    { title: "Kognitiv Revolusjon", date: "(ca. 50 000 år fvt.)" },
                    { title: "Jordbruksrevolusjon", date: "(ca. 10 000 år fvt.)" },
                ];
                
                const startX = -300;
                const endX = 15;
                const currentX = startX + (endX - startX) * animLeft;
                const arrowY = 20;
                
                ctx.globalAlpha = animLeft;
                ctx.beginPath();
                ctx.moveTo(currentX + 15, arrowY);
                ctx.lineTo(currentX, arrowY);
                ctx.moveTo(currentX, arrowY);
                ctx.lineTo(currentX + 6, arrowY - 5);
                ctx.moveTo(currentX, arrowY);
                ctx.lineTo(currentX + 6, arrowY + 5);
                ctx.stroke();

                ctx.textAlign = 'left';
                let currentY = arrowY + 15;
                leftTexts.forEach(item => {
                    ctx.font = 'bold 9px Inter';
                    ctx.fillText(item.title, currentX + 25, currentY);
                    ctx.font = '7px Inter';
                    ctx.fillText(item.date, currentX + 25, currentY + 10);
                    currentY += 22;
                });
            }

            if (animRight > 0) {
                const rightTexts = [
                    { title: "Pangea Ultima dannes", date: "(Ca. 250 mill. år)" },
                    { title: "Havene fordamper", date: "(ca. 1 mrd. år)" },
                    { title: "Solen starter å dø", date: "(ca. 5 mrd. år)" },
                    { title: "Bare svarte hull gjenstår", date: "(ca. 100 trillioner år)" },
                ];

                const startX = canvasWidth + 300;
                const endX = canvasWidth - 15;
                const currentX = startX + (endX - startX) * animRight;
                const arrowY = 20;

                ctx.globalAlpha = animRight;
                ctx.beginPath();
                ctx.moveTo(currentX - 15, arrowY);
                ctx.lineTo(currentX, arrowY);
                ctx.moveTo(currentX, arrowY);
                ctx.lineTo(currentX - 6, arrowY - 5);
                ctx.moveTo(currentX, arrowY);
                ctx.lineTo(currentX - 6, arrowY + 5);
                ctx.stroke();

                ctx.textAlign = 'right';
                let currentY = arrowY + 15;
                rightTexts.forEach(item => {
                    ctx.font = 'bold 9px Inter';
                    ctx.fillText(item.title, currentX - 25, currentY);
                    ctx.font = '7px Inter';
                    ctx.fillText(item.date, currentX - 25, currentY + 10);
                    currentY += 22;
                });
            }

            ctx.restore();
        }

        function drawHoverIndicator() {
            if ((state.dragging.isDown && state.dragging.dragType !== 'create') || (!state.dragging.isDown && state.mouse.isOverItem)) {
                return;
            }
            const dpr = window.devicePixelRatio || 1;
            const canvasHeight = canvas.height / dpr;
            const axisY = (canvasHeight / 2) + state.view.panY;
            const x = state.mouse.x;
            const y = axisY - 30;

            ctx.globalAlpha = 0.5;
            ctx.beginPath(); 
            ctx.moveTo(x, axisY); 
            ctx.lineTo(x, y); 
            ctx.strokeStyle = '#A0AEC0'; 
            ctx.lineWidth = 2; 
            ctx.stroke();
            
            ctx.beginPath(); 
            ctx.arc(x, y, 6, 0, Math.PI * 2); 
            ctx.fillStyle = '#A0AEC0'; 
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(x, axisY);
            ctx.lineTo(x, canvasHeight);
            ctx.stroke();

            const date = pxToDate(x);
            const yearText = formatYearWithMonth(date);
            ctx.font = '12px Inter';
            ctx.fillStyle = '#A0AEC0';
            ctx.textAlign = 'left';
            ctx.fillText(yearText, x + 10, y + 4);

            ctx.globalAlpha = 1.0;
        }

        function drawCreationRect() {
            if (!state.dragging.creationRect) return;
            const rect = state.dragging.creationRect;
            const x = Math.min(rect.startX, rect.endX);
            const width = Math.abs(rect.endX - rect.startX);
            const axisY = (canvas.height / window.devicePixelRatio / 2) + state.view.panY;
            
            ctx.fillStyle = 'rgba(66, 153, 225, 0.3)';
            ctx.strokeStyle = 'rgba(43, 108, 176, 0.8)';
            ctx.lineWidth = 1;
            ctx.fillRect(x, axisY + 30, width, 40);
            ctx.strokeRect(x, axisY + 30, width, 40);
        }

        function getMarkerInterval() {
            const yearsOnScreen = (canvas.width / window.devicePixelRatio) / state.view.zoom;
            const adjustedYears = yearsOnScreen / state.view.markerDensity;
            if (adjustedYears > 5000) return 1000;
            if (adjustedYears > 2000) return 500;
            if (adjustedYears > 1000) return 200;
            if (adjustedYears > 500) return 100;
            if (adjustedYears > 200) return 50;
            if (adjustedYears > 100) return 20;
            if (adjustedYears > 50) return 10;
            if (adjustedYears > 20) return 5;
            if (adjustedYears > 10) return 2;
            return 1;
        }

        function drawMarkers(axisY) {
            const interval = getMarkerInterval();
            const startYear = Math.floor(pxToDate(0) / interval) * interval;
            const endYear = Math.ceil(pxToDate(canvas.width / window.devicePixelRatio) / interval) * interval;

            ctx.fillStyle = '#4A5568'; ctx.textAlign = 'center'; ctx.font = '12px Inter';

            for (let year = startYear; year <= endYear; year += interval) {
                const x = dateToPx(year);
                if (x < 0 || x > canvas.width / window.devicePixelRatio) continue;
                const isMajor = year % (interval * 10) === 0;
                const tickHeight = isMajor ? 15 : 8;
                ctx.beginPath(); ctx.moveTo(x, axisY - tickHeight); ctx.lineTo(x, axisY + tickHeight);
                ctx.strokeStyle = '#4A5568'; ctx.lineWidth = isMajor ? 2 : 1; ctx.stroke();
                
                if (isMajor || state.view.zoom > (5 / state.view.markerDensity)) {
                    ctx.fillText(formatYear(year), x, axisY + tickHeight + 15);
                }

                // NEW: Draw month markers if zoomed in enough
                if (state.view.zoom > MONTH_ZOOM_THRESHOLD && interval <= 1) {
                    for (let i = 1; i < 12; i++) {
                        const monthX = dateToPx(year + i / 12);
                        const monthTickHeight = 5;
                        ctx.beginPath();
                        ctx.moveTo(monthX, axisY - monthTickHeight);
                        ctx.lineTo(monthX, axisY + monthTickHeight);
                        ctx.strokeStyle = '#A0AEC0'; // Lighter color for months
                        ctx.lineWidth = 0.5;
                        ctx.stroke();
                        
                        // Draw month name if enough space
                        if (state.view.zoom > MONTH_ZOOM_THRESHOLD * 2.5) {
                            ctx.font = '9px Inter';
                            ctx.fillStyle = '#718096';
                            ctx.fillText(MONTH_NAMES[i], monthX, axisY - monthTickHeight - 5);
                        }
                    }
                }
            }
        }

        function drawEvents(context, coordFn, events, images, axisY, showDescriptions) {
            const radius = 8;
            events.forEach(event => {
                const color = event.color || '#38A169';
                const x = coordFn(event.date);
                
                if (showDescriptions && event.height > 0) {
                    const boxWidth = 180;
                    const boxX = x - boxWidth / 2;
                    context.fillStyle = '#FFFFFF';
                    context.strokeStyle = color;
                    context.lineWidth = 1;
                    context.beginPath();
                    context.roundRect(boxX, event.y, boxWidth, event.height, radius);
                    context.fill();
                    context.stroke();

                    context.save();
                    context.clip();

                    context.fillStyle = '#2D3748';
                    context.font = 'bold 14px Inter';
                    context.textAlign = 'center';
                    context.fillText(event.title, x, event.y + 15);

                    let currentY = event.y + 30;
                    if (event.descriptionLines && event.descriptionLines.length > 0) {
                        const fontSize = getDynamicFontSize(event.descriptionLines.length);
                        const lineHeight = fontSize * 1.2;
                        context.font = `${fontSize}px Inter`;
                        context.fillStyle = '#4A5568';
                        event.descriptionLines.forEach(line => {
                            context.fillText(line, x, currentY);
                            currentY += lineHeight;
                        });
                    }

                    if (event.img && images[event.img]) {
                        const img = images[event.img];
                        const thumbHeight = 50;
                        const thumbWidth = thumbHeight * (img.width / img.height);
                        const imgX = x - thumbWidth / 2;
                        const imgY = currentY + (event.description ? 5 : 0);
                        context.drawImage(img, imgX, imgY, thumbWidth, thumbHeight);
                    }
                    context.restore();
                    context.beginPath(); context.moveTo(x, axisY); context.lineTo(x, event.y + event.height); context.strokeStyle = color; context.lineWidth = 2; context.stroke();
                } else {
                    context.beginPath(); context.moveTo(x, axisY); context.lineTo(x, event.y); context.strokeStyle = color; context.lineWidth = 2; context.stroke();
                    context.beginPath(); context.arc(x, event.y, 6, 0, Math.PI * 2); context.fillStyle = color; context.fill();
                    context.fillStyle = '#2D3748'; context.font = 'bold 14px Inter'; context.textAlign = 'center'; context.fillText(event.title, x, event.y - 15);
                }
            });
        }
        
        function drawPeriods(context, coordFn, periods, images, showDescriptions) {
            periods.forEach(period => {
                const color = period.color || '#4299E1';
                const startX = coordFn(period.startDate);
                const endX = coordFn(period.endDate);
                const width = endX - startX;

                if (period.isApproximate && width > 0) {
                    const gradient = context.createLinearGradient(startX, 0, endX, 0);
                    const fadeWidth = Math.min(width / 2, 20);
                    const fadeStart = fadeWidth / width;
                    const fadeEnd = 1 - fadeStart;
                    const baseColor = hexToRgba(color, 0.7);
                    const transparentColor = hexToRgba(color, 0);
                    
                    gradient.addColorStop(0, transparentColor);
                    gradient.addColorStop(fadeStart, baseColor);
                    gradient.addColorStop(fadeEnd, baseColor);
                    gradient.addColorStop(1, transparentColor);
                    context.fillStyle = gradient;
                } else {
                    context.fillStyle = hexToRgba(color, 0.7); 
                }
                context.beginPath(); 
                context.rect(startX, period.y, width, period.height); 
                context.fill();
                
                context.font = 'bold 14px Inter';
                const titleWidth = context.measureText(period.title).width;
                const isTitleOutOfBounds = titleWidth > width - 20;

                const titleX = startX + width / 2;
                let titleY = period.y + 15;
                
                const yearRangeText = `(${formatYearWithMonth(period.startDate, period.isApproximate)} - ${formatYearWithMonth(period.endDate, period.isApproximate)})`;
                context.font = '9px Inter';
                const yearRangeWidth = context.measureText(yearRangeText).width;
                if (isTitleOutOfBounds || yearRangeWidth > width - 20) {
                } else {
                    if (!isTitleOutOfBounds) {
                        titleY -= 5;
                    }
                }
                
                context.font = 'bold 14px Inter';
                if (isTitleOutOfBounds) {
                    context.save();
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.strokeStyle = 'white';
                    context.lineWidth = 3;
                    context.strokeText(period.title, titleX, titleY);
                    context.fillStyle = '#1A202C'; 
                    context.fillText(period.title, titleX, titleY);
                    context.restore();
                } else {
                    context.fillStyle = '#1A202C'; 
                    context.fillText(period.title, titleX, titleY);
                }
                
                if (!isTitleOutOfBounds && !(yearRangeWidth > width - 20)) {
                    context.font = '9px Inter';
                    context.fillStyle = '#4A5568';
                    const yearRangeY = titleY + 14;
                    context.fillText(yearRangeText, titleX, yearRangeY);
                }

                
                context.save();
                context.beginPath();
                context.rect(startX, period.y, width, period.height);
                context.clip();

                let currentY = period.y + 34;
                if (showDescriptions && period.descriptionLines && period.descriptionLines.length > 0) {
                    const fontSize = getDynamicFontSize(period.descriptionLines.length);
                    const lineHeight = fontSize * 1.2;
                    context.font = `${fontSize}px Inter`;
                    context.fillStyle = '#2D3748';
                    context.textBaseline = 'top';
                    period.descriptionLines.forEach((line, i) => {
                        context.fillText(line, startX + width / 2, currentY);
                        currentY += lineHeight;
                    });
                }

                if (showDescriptions && period.img && images[period.img]) {
                    const img = images[period.img];
                    const thumbHeight = 50;
                    const thumbWidth = thumbHeight * (img.width / img.height);
                    const imgX = startX + (width - thumbWidth) / 2;
                    const imgY = currentY + (period.description ? 5 : 0);
                    context.drawImage(img, imgX, imgY, thumbWidth, thumbHeight);
                }
                context.restore();
            });
        }
        
        // --- Image Loading ---
        function loadImage(item) {
            if (item.img && !state.images[item.img]) {
                const image = new Image();
                image.crossOrigin = "anonymous";
                image.src = item.img;
                image.onload = () => { state.images[item.img] = image; requestDraw(); };
                image.onerror = () => { console.error(`Failed to load image: ${item.img}`); state.images[item.img] = null; }
            }
        }

        // --- Event Handlers ---
        setDateRangeBtn.addEventListener('click', () => {
            let start = parseInt(startDateInput.value, 10);
            let end = parseInt(endDateInput.value, 10);

            if (isNaN(start) || isNaN(end) || start >= end) {
                showConfirm('Vennligst skriv inn et gyldig start- og sluttår.', () => {}, true);
                return;
            }

            start = Math.max(MASTER_TIMELINE_START, start);
            end = Math.min(MASTER_TIMELINE_END, end);
            startDateInput.value = start;
            endDateInput.value = end;
            
            state.view.start = start;
            state.view.end = end;
            
            updateViewForNewRange();
        });

        function updateViewForNewRange() {
            const dpr = window.devicePixelRatio || 1;
            const canvasWidth = canvas.width / dpr;
            const totalYears = state.view.end - state.view.start;
            
            MIN_ZOOM_LEVEL = canvasWidth / (totalYears * 1.1);
            state.view.zoom = MIN_ZOOM_LEVEL;
            state.view.panX = 0;
            clampPanX();
            updateZoomSlider();
            requestDraw();
        }

        function updateZoomSlider() {
            if (!zoomLevelSlider || !MIN_ZOOM_LEVEL) return;
            const maxZoom = 500; // Increased max zoom for months
            const sliderValue = 100 * Math.log(state.view.zoom / MIN_ZOOM_LEVEL) / Math.log(maxZoom / MIN_ZOOM_LEVEL);
            zoomLevelSlider.value = Math.max(0, sliderValue);
        }

        zoomLevelSlider.addEventListener('input', (e) => {
            const sliderValue = parseFloat(e.target.value);
            if (!MIN_ZOOM_LEVEL) return;
            const maxZoom = 500;

            const newZoom = MIN_ZOOM_LEVEL * Math.pow(maxZoom / MIN_ZOOM_LEVEL, sliderValue / 100);

            const dpr = window.devicePixelRatio || 1;
            const canvasWidth = canvas.width / dpr;
            const dateAtCenter = pxToDate(canvasWidth / 2);

            state.view.zoom = newZoom;
            state.view.panX = (canvasWidth / 2) - (dateAtCenter - state.view.start) * state.view.zoom;
            
            clampPanX();
            requestDraw();
        });

        zoomSensitivitySlider.addEventListener('input', (e) => {
            state.view.markerDensity = parseFloat(e.target.value);
            requestDraw();
        });

        showDescriptionsToggle.addEventListener('change', (e) => {
            state.view.showDescriptions = e.target.checked;
            document.getElementById('exportDescriptions').checked = e.target.checked;
            requestDraw();
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const zoomFactor = 1.1;
            const dateAtMouse = pxToDate(mouseX);
            
            let newZoom = state.view.zoom;
            if (e.deltaY < 0) { newZoom *= zoomFactor; } 
            else { newZoom /= zoomFactor; }
            
            state.view.zoom = Math.max(MIN_ZOOM_LEVEL, newZoom);
            state.view.panX = mouseX - (dateAtMouse - state.view.start) * state.view.zoom;
            
            clampPanX();
            updateZoomSlider();
            requestDraw();
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            state.dragging.isDown = true;
            state.dragging.startX = e.clientX;
            state.dragging.startY = e.clientY;
            state.dragging.lastX = e.clientX;
            state.dragging.lastY = e.clientY;
            state.dragging.scrollLeft = state.view.panX;
            state.dragging.scrollTop = state.view.panY;

            const item = getPeriodAt(mouseX, mouseY) || getEventAt(mouseX, mouseY);
            const axisY = (canvas.height / window.devicePixelRatio / 2) + state.view.panY;
            const distFromAxis = Math.abs(mouseY - axisY);
            const actionZoneThreshold = 50;

            if (item) {
                state.dragging.activeItem = item;
                if (item.type === 'period') {
                    const startPx = dateToPx(item.item.startDate);
                    const endPx = dateToPx(item.item.endDate);
                    const handleSize = 10;
                    if (mouseX > endPx - handleSize) { state.dragging.dragType = 'resize-right'; } 
                    else if (mouseX < startPx + handleSize) { state.dragging.dragType = 'resize-left'; } 
                    else { state.dragging.dragType = 'move'; }
                } else {
                    state.dragging.dragType = 'move';
                }
            } else if (distFromAxis < actionZoneThreshold) {
                state.dragging.dragType = 'create';
                state.dragging.creationRect = { startX: mouseX, endX: mouseX };
            } else {
                state.dragging.dragType = 'pan';
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!state.dragging.isDown) return;

            if (state.dragging.dragType === 'reorder' && state.dragging.targetPeriod) {
                const activePeriod = state.dragging.activeItem.item;
                const targetPeriod = state.dragging.targetPeriod;

                const activeOrder = activePeriod.renderOrder;
                activePeriod.renderOrder = targetPeriod.renderOrder;
                targetPeriod.renderOrder = activeOrder;

                state.periods.sort((a,b) => (a.renderOrder || 0) - (b.renderOrder || 0));
                state.periods.forEach((p, i) => p.renderOrder = i);
            }

            const dragDistance = Math.sqrt(Math.pow(e.clientX - state.dragging.startX, 2) + Math.pow(e.clientY - state.dragging.startY, 2));
            
            const snapToMonth = state.view.zoom > MONTH_ZOOM_THRESHOLD;
            const snapFunc = (date) => {
                if (snapToMonth) {
                    const year = Math.floor(date);
                    const monthDecimal = (date - year) * 12;
                    return year + Math.round(monthDecimal) / 12;
                }
                return Math.round(date);
            };

            if (dragDistance >= 5) { // It's a drag
                if (state.dragging.activeItem) {
                    const item = state.dragging.activeItem.item;
                    const type = state.dragging.activeItem.type;
                    if (type === 'event') {
                        item.date = snapFunc(item.date);
                    } else if (type === 'period') {
                        item.startDate = snapFunc(item.startDate);
                        item.endDate = snapFunc(item.endDate);
                        if (item.startDate >= item.endDate) {
                            item.endDate = item.startDate + (snapToMonth ? 1/12 : 1);
                        }
                    }
                } else if (state.dragging.dragType === 'create' && state.dragging.creationRect) {
                    const rect = state.dragging.creationRect;
                    const startDate = pxToDate(Math.min(rect.startX, rect.endX));
                    const endDate = pxToDate(Math.max(rect.startX, rect.endX));
                    const snappedStartDate = snapFunc(startDate);
                    const snappedEndDate = snapFunc(endDate);

                    if (snappedEndDate > snappedStartDate) {
                        openPeriodModal(null, { startDate: snappedStartDate, endDate: snappedEndDate });
                    }
                }
            } else { // It's a click
                if (state.dragging.activeItem) {
                    showDetails(state.dragging.activeItem.item, state.dragging.activeItem.type);
                } else if (state.dragging.dragType === 'create') {
                    const clickedDate = pxToDate(state.dragging.creationRect.startX);
                    const snappedDate = snapFunc(clickedDate);
                    openEventModal(null, snappedDate);
                }
            }

            state.dragging.isDown = false;
            canvas.classList.remove('grabbing');
            state.dragging.activeItem = null;
            state.dragging.creationRect = null;
            state.dragging.dragType = null;
            state.dragging.targetPeriod = null;
            requestDraw();
            saveState();
        });

        canvas.addEventListener('mouseleave', () => {
            state.mouse.x = -1; state.mouse.y = -1;
            if (state.dragging.isDown) {
                state.dragging.isDown = false;
                state.dragging.creationRect = null;
                state.dragging.dragType = null;
                canvas.classList.remove('grabbing');
                canvas.style.cursor = 'grab';
                saveState();
            }
            requestDraw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            state.mouse.x = mouseX;
            state.mouse.y = mouseY;
            state.mouse.hoverDetail = null;

            if (state.dragging.isDown) {
                canvas.classList.add('grabbing');
                
                if (state.dragging.activeItem) {
                    const dy = e.clientY - state.dragging.lastY;
                    if (state.dragging.activeItem.type === 'period' && Math.abs(dy) > 10 && state.dragging.dragType === 'move') {
                        state.dragging.dragType = 'reorder';
                    }

                    if (state.dragging.dragType === 'reorder') {
                        const activeId = state.dragging.activeItem.item.id;
                        state.dragging.targetPeriod = state.periods.find(p => {
                            if (p.id === activeId) return false;
                            const startX = dateToPx(p.startDate);
                            const endX = dateToPx(p.endDate);
                            return mouseX >= startX && mouseX <= endX && mouseY >= p.y && mouseY <= p.y + p.height;
                        });
                    } else {
                        const dx = e.clientX - state.dragging.lastX;
                        const item = state.dragging.activeItem.item;
                        const type = state.dragging.activeItem.type;
                        const dateChange = dx / state.view.zoom;

                        if (state.dragging.dragType === 'move') {
                            if (type === 'event') { item.date += dateChange; } 
                            else { item.startDate += dateChange; item.endDate += dateChange; }
                        } else if (type === 'period') {
                            if (state.dragging.dragType === 'resize-right') { item.endDate = Math.max(item.startDate + 0.01, pxToDate(mouseX)); } 
                            else if (state.dragging.dragType === 'resize-left') { item.startDate = Math.min(item.endDate - 0.01, pxToDate(mouseX)); }
                        }
                    }
                    state.dragging.lastX = e.clientX;
                    state.dragging.lastY = e.clientY;
                } else if (state.dragging.dragType === 'create') {
                    state.dragging.creationRect.endX = mouseX;
                } else if (state.dragging.dragType === 'pan') {
                    const dx = e.clientX - state.dragging.startX;
                    const dy = e.clientY - state.dragging.startY;
                    state.view.panX = state.dragging.scrollLeft + dx;
                    state.view.panY = state.dragging.scrollTop + dy;
                    clampPanX();
                }
            } else {
                const item = getPeriodAt(mouseX, mouseY) || getEventAt(mouseX, mouseY);
                state.mouse.isOverItem = !!item;
                if (item) {
                    if (item.type === 'period') {
                        const period = item.item;
                        const startPx = dateToPx(period.startDate);
                        const endPx = dateToPx(period.endDate);
                        const handleSize = 10;

                        if (!period.isApproximate) {
                            if (mouseX > endPx - handleSize) {
                                canvas.style.cursor = 'ew-resize';
                                state.mouse.hoverDetail = { type: 'period-edge', side: 'right', item: period };
                            } else if (mouseX < startPx + handleSize) {
                                canvas.style.cursor = 'ew-resize';
                                state.mouse.hoverDetail = { type: 'period-edge', side: 'left', item: period };
                            } else {
                                canvas.style.cursor = 'move';
                            }
                        } else {
                             canvas.style.cursor = 'move';
                        }
                    } else {
                        canvas.style.cursor = 'move';
                    }
                } else {
                    const axisY = (canvas.height / window.devicePixelRatio / 2) + state.view.panY;
                    const distFromAxis = Math.abs(mouseY - axisY);
                    const actionZoneThreshold = 50;
                    if (distFromAxis < actionZoneThreshold) {
                        canvas.style.cursor = 'crosshair';
                    } else {
                        canvas.style.cursor = 'grab';
                    }
                }
            }
            requestDraw();
        });
        
        function getEventAt(x, y) {
            for (let i = state.events.length - 1; i >= 0; i--) {
                const event = state.events[i];
                const eventX = dateToPx(event.date);
                if (event.height > 0 && state.view.showDescriptions) {
                    const boxWidth = 180;
                    const boxX = eventX - boxWidth / 2;
                    if (x >= boxX && x <= boxX + boxWidth && y >= event.y && y <= event.y + event.height) {
                        return { item: event, index: i, type: 'event' };
                    }
                } else {
                    const dist = Math.sqrt(Math.pow(x - eventX, 2) + Math.pow(y - event.y, 2));
                    if (dist <= 10) return { item: event, index: i, type: 'event' };
                }
            }
            return null;
        }

        function getPeriodAt(x, y) {
            for (let i = state.periods.length - 1; i >= 0; i--) {
                const period = state.periods[i];
                const startX = dateToPx(period.startDate);
                const endX = dateToPx(period.endDate);
                if (x >= startX && x <= endX && y >= period.y && y <= period.y + period.height) {
                    return { item: period, index: i, type: 'period' };
                }
            }
            return null;
        }

        // --- Mini Navigator Logic ---
        function drawMiniNavigator() {
            const dpr = window.devicePixelRatio || 1;
            const { width, height } = miniCanvas;
            const viewWidth = width / dpr;
            const viewHeight = height / dpr;

            miniCtx.clearRect(0, 0, viewWidth, viewHeight);

            miniCtx.fillStyle = '#f7fafc';
            miniCtx.fillRect(0, 0, viewWidth, viewHeight);

            miniCtx.fillStyle = '#cbd5e0';
            miniCtx.fillRect(0, viewHeight / 2 - 1, viewWidth, 2);

            const masterDuration = MASTER_TIMELINE_END - MASTER_TIMELINE_START;
            const yearToPx = (year) => ((year - MASTER_TIMELINE_START) / masterDuration) * viewWidth;

            state.periods.forEach(p => {
                const startX = yearToPx(p.startDate);
                const endX = yearToPx(p.endDate);
                miniCtx.fillStyle = p.color || '#4299E1';
                miniCtx.fillRect(startX, viewHeight * 0.5, endX - startX, viewHeight * 0.5);
            });

            state.events.forEach(e => {
                const x = yearToPx(e.date);
                miniCtx.fillStyle = e.color || '#38A169';
                miniCtx.fillRect(x - 1, 0, 2, viewHeight * 0.5);
            });

            const viewStartOnMaster = pxToDate(0);
            const viewEndOnMaster = pxToDate(viewWidth);
            const viewStartPx = yearToPx(viewStartOnMaster);
            const viewEndPx = yearToPx(viewEndOnMaster);

            miniCtx.fillStyle = 'rgba(128, 90, 213, 0.3)'; // purple-500 with alpha
            miniCtx.fillRect(viewStartPx, 0, viewEndPx - viewStartPx, viewHeight);
            miniCtx.strokeStyle = 'rgba(107, 33, 168, 0.6)'; // purple-800 with alpha
            miniCtx.lineWidth = 1;
            miniCtx.strokeRect(viewStartPx, 0, viewEndPx - viewStartPx, viewHeight);
        }

        function handleMiniNavInteraction(e) {
            const rect = miniCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            
            const masterDuration = MASTER_TIMELINE_END - MASTER_TIMELINE_START;
            const clickedYear = (mouseX / miniCanvas.clientWidth) * masterDuration + MASTER_TIMELINE_START;
            
            centerOnYear(clickedYear);
        }

        function centerOnYear(year) {
            const dpr = window.devicePixelRatio || 1;
            const canvasWidth = canvas.width / dpr;
            
            const targetPanX = (canvasWidth / 2) - (year - state.view.start) * state.view.zoom;
            state.view.panX = targetPanX;

            clampPanX();
            requestDraw();
        }

        miniCanvas.addEventListener('mousedown', (e) => {
            state.miniNavDragging = true;
            handleMiniNavInteraction(e);
        });
        miniCanvas.addEventListener('mousemove', (e) => {
            if (state.miniNavDragging) {
                handleMiniNavInteraction(e);
            }
        });
        miniCanvas.addEventListener('mouseup', () => {
            state.miniNavDragging = false;
        });
        miniCanvas.addEventListener('mouseleave', () => {
            state.miniNavDragging = false;
        });
        
        jumpToYearBtn.addEventListener('click', () => {
            const year = parseInt(jumpToYearInput.value, 10);
            if (!isNaN(year)) {
                centerOnYear(year);
            }
        });
        jumpToYearInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const year = parseInt(jumpToYearInput.value, 10);
                if (!isNaN(year)) {
                    centerOnYear(year);
                }
            }
        });


        // --- Modal Logic ---
        function openModal(modal) { modal.classList.add('active'); }
        function closeModal(modal) { modal.classList.remove('active'); }

        function showDetails(item, type) {
            state.editingItemId = item.id;
            state.editingItemType = type;
            document.getElementById('detailsTitle').textContent = item.title;
            document.getElementById('detailsDesc').textContent = item.description || 'Ingen beskrivelse.';
            const imgEl = document.getElementById('detailsImg');
            const imgErrorEl = document.getElementById('detailsImgError');
            if (item.img) {
                imgEl.src = item.img;
                imgEl.style.display = 'block';
                imgErrorEl.style.display = 'none';
            } else {
                imgEl.style.display = 'none';
                imgErrorEl.style.display = 'none';
            }
            openModal(detailsModal);
        }
        
        document.getElementById('closeDetails').addEventListener('click', () => closeModal(detailsModal));
        document.getElementById('cancelEvent').addEventListener('click', () => closeModal(eventModal));
        document.getElementById('cancelPeriod').addEventListener('click', () => closeModal(periodModal));
        document.getElementById('cancelExport').addEventListener('click', () => closeModal(exportModal));
        document.getElementById('cancelExportJpeg').addEventListener('click', () => closeModal(exportJpegSettingsModal));

        document.getElementById('editItemBtn').addEventListener('click', () => {
            const id = state.editingItemId;
            const type = state.editingItemType;
            if (!id || !type) return;
            if (type === 'event') {
                const event = state.events.find(e => e.id === id);
                openEventModal(event);
            } else if (type === 'period') {
                const period = state.periods.find(p => p.id === id);
                openPeriodModal(period);
            }
            closeModal(detailsModal);
        });

        document.getElementById('deleteItemBtn').addEventListener('click', () => {
            showConfirm('Er du sikker på at du vil slette dette elementet?', () => {
                const id = state.editingItemId;
                const type = state.editingItemType;
                if (type === 'event') { state.events = state.events.filter(e => e.id !== id); } 
                else if (type === 'period') { state.periods = state.periods.filter(p => p.id !== id); }
                closeModal(detailsModal);
                requestDraw();
                saveState();
            });
        });

        clearAllBtn.addEventListener('click', () => {
            showConfirm('Er du sikker på at du vil slette ALLE hendelser og perioder? Denne handlingen kan ikke angres.', () => {
                state.events = [];
                state.periods = [];
                requestDraw();
                saveState();
            });
        });

        function showConfirm(message, onConfirm, isInfo = false) {
            document.getElementById('confirmText').textContent = message;
            document.getElementById('confirmTitle').textContent = isInfo ? 'Informasjon' : 'Er du sikker?';
            const okBtn = document.getElementById('confirmOk');
            okBtn.textContent = isInfo ? 'OK' : 'Slett';
            okBtn.className = isInfo 
                ? 'px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700' 
                : 'px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700';
            
            openModal(confirmModal);

            const confirmCancel = document.getElementById('confirmCancel');
            
            const okListener = () => { onConfirm(); closeModal(confirmModal); cleanup(); };
            const cancelListener = () => { closeModal(confirmModal); cleanup(); };
            
            const cleanup = () => {
                okBtn.removeEventListener('click', okListener);
                confirmCancel.removeEventListener('click', cancelListener);
            };
            
            okBtn.addEventListener('click', okListener, { once: true });
            confirmCancel.addEventListener('click', cancelListener, { once: true });
        }


        function openEventModal(event = null, date = null) {
            document.getElementById('eventForm').reset();
            const colorPicker = document.getElementById('eventColor');
            const charCount = document.getElementById('eventCharCount');
            const descTextarea = document.getElementById('eventDesc');

            const updateCharCount = () => {
                charCount.textContent = `${descTextarea.value.length} / 120`;
            };
            descTextarea.addEventListener('input', updateCharCount);

            if (event) { // Editing
                document.getElementById('eventModalTitle').textContent = 'Rediger hendelse';
                document.getElementById('saveEventBtn').textContent = 'Lagre endringer';
                document.getElementById('eventId').value = event.id;
                document.getElementById('eventDate').value = event.date;
                document.getElementById('eventTitle').value = event.title;
                descTextarea.value = event.description || '';
                document.getElementById('eventImg').value = event.img;
                colorPicker.value = event.color || '#38A169';
            } else { // Creating new
                document.getElementById('eventModalTitle').textContent = 'Legg til ny hendelse';
                document.getElementById('saveEventBtn').textContent = 'Legg til hendelse';
                document.getElementById('eventId').value = '';
                descTextarea.value = '';
                colorPicker.value = '#38A169';
                if (date !== null) document.getElementById('eventDate').value = date.toFixed(2);
            }
            updateCharCount();
            openModal(eventModal);
        }

        function openPeriodModal(period = null, dates = null) {
            document.getElementById('periodForm').reset();
            const colorPicker = document.getElementById('periodColor');
            const isApproximateCheckbox = document.getElementById('periodIsApproximate');
            const charCount = document.getElementById('periodCharCount');
            const descTextarea = document.getElementById('periodDesc');
            
            const updateCharCount = () => {
                charCount.textContent = `${descTextarea.value.length} / 120`;
            };
            descTextarea.addEventListener('input', updateCharCount);

            if (period) { // Editing
                document.getElementById('periodModalTitle').textContent = 'Rediger periode';
                document.getElementById('savePeriodBtn').textContent = 'Lagre endringer';
                document.getElementById('periodId').value = period.id;
                document.getElementById('periodStartDate').value = period.startDate;
                document.getElementById('periodEndDate').value = period.endDate;
                document.getElementById('periodTitle').value = period.title;
                descTextarea.value = period.description || '';
                document.getElementById('periodImg').value = period.img;
                colorPicker.value = period.color || '#4299E1';
                isApproximateCheckbox.checked = period.isApproximate || false;
            } else { // Creating new
                document.getElementById('periodModalTitle').textContent = 'Legg til ny periode';
                document.getElementById('savePeriodBtn').textContent = 'Legg til periode';
                document.getElementById('periodId').value = '';
                descTextarea.value = '';
                colorPicker.value = '#4299E1';
                isApproximateCheckbox.checked = false;
                if (dates) {
                    document.getElementById('periodStartDate').value = dates.startDate.toFixed(2);
                    document.getElementById('periodEndDate').value = dates.endDate.toFixed(2);
                }
            }
            updateCharCount();
            openModal(periodModal);
        }

        addEventBtn.addEventListener('click', () => openEventModal(null, pxToDate(canvas.width / window.devicePixelRatio / 2)));
        addPeriodBtn.addEventListener('click', () => openPeriodModal());

        document.getElementById('eventForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const eventId = document.getElementById('eventId').value;
            const data = {
                date: parseFloat(document.getElementById('eventDate').value),
                title: document.getElementById('eventTitle').value,
                description: document.getElementById('eventDesc').value,
                img: document.getElementById('eventImg').value,
                color: document.getElementById('eventColor').value,
            };
            if (eventId) {
                const index = state.events.findIndex(ev => ev.id == eventId);
                if (index !== -1) state.events[index] = { ...state.events[index], ...data };
            } else {
                data.id = Date.now();
                state.events.push(data);
            }
            loadImage(data); requestDraw(); e.target.reset(); closeModal(eventModal);
            saveState();
        });

        document.getElementById('periodForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const periodId = document.getElementById('periodId').value;
            const data = {
                startDate: parseFloat(document.getElementById('periodStartDate').value),
                endDate: parseFloat(document.getElementById('periodEndDate').value),
                title: document.getElementById('periodTitle').value,
                description: document.getElementById('periodDesc').value,
                img: document.getElementById('periodImg').value,
                color: document.getElementById('periodColor').value,
                isApproximate: document.getElementById('periodIsApproximate').checked,
            };
            if (data.startDate >= data.endDate) { showConfirm('Startdato må være før sluttdato.', () => {}, true); return; }
            if (periodId) {
                const index = state.periods.findIndex(p => p.id == periodId);
                if (index !== -1) state.periods[index] = { ...state.periods[index], ...data };
            } else {
                data.id = Date.now();
                data.renderOrder = state.periods.length;
                state.periods.push(data);
            }
            loadImage(data); requestDraw(); e.target.reset(); closeModal(periodModal);
            saveState();
        });

        // --- Import/Export Logic ---
        const EXPORT_DATA_MARKER = 'TIMELINE_DATA_JSON=';
        
        function getTimelineData() {
            return {
                events: state.events.map(({lane, y, height, descriptionLines, ...rest}) => rest),
                periods: state.periods.map(({lane, y, height, descriptionLines, ...rest}) => rest),
            };
        }

        exportBtn.addEventListener('click', () => openModal(exportModal));
        
        function getTimelineBounds() {
            if (state.events.length === 0 && state.periods.length === 0) {
                return { min: state.view.start, max: state.view.end };
            }
            const eventDates = state.events.map(e => e.date);
            const periodStartDates = state.periods.map(p => p.startDate);
            const periodEndDates = state.periods.map(p => p.endDate);
            const allDates = [...eventDates, ...periodStartDates, ...periodEndDates];
            const min = Math.min(...allDates);
            const max = Math.max(...allDates);
            const margin = (max - min) * 0.05 || 1;
            return { min: min - margin, max: max + margin };
        }

        document.getElementById('exportJpegAutoBtn').addEventListener('click', () => {
            const bounds = getTimelineBounds();
            const showDescriptions = state.view.showDescriptions;
            
            const idealWidth = (bounds.max - bounds.min) * 1;
            let width = Math.max(1920, Math.min(6000, idealWidth));
            
            let { totalHeight } = getExportLayout(bounds.min, bounds.max, width, showDescriptions);
            let height = totalHeight;

            if (height > 6000) {
                const scaleFactor = 6000 / height;
                height = 6000;
                width = Math.round(width * scaleFactor);
            }

            exportJpeg(bounds.min, bounds.max, width, height, showDescriptions);
            closeModal(exportModal);
        });
        
        document.getElementById('exportJpegSettingsBtn').addEventListener('click', () => {
            const bounds = getTimelineBounds();
            document.getElementById('exportStartDate').value = Math.floor(bounds.min);
            document.getElementById('exportEndDate').value = Math.ceil(bounds.max);
            
            const idealWidth = (bounds.max - bounds.min) * 1;
            const width = Math.max(1920, Math.min(6000, idealWidth));
            document.getElementById('exportWidth').value = width;

            document.getElementById('exportDescriptions').checked = state.view.showDescriptions;
            updateCalculatedExportHeight();
            openModal(exportJpegSettingsModal);
        });
        
        function getExportLayout(start, end, width, showDescriptions) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            const dateToPxExport = (date) => (date - start) * (width / (end - start));

            const layout = { events: [], periods: [] };
            const topPadding = 30;
            const vSpacing = 15;

            const skylineUp = [];
            const sortedEvents = JSON.parse(JSON.stringify(state.events)).sort((a, b) => a.date - b.date);
            
            sortedEvents.forEach(event => {
                const eventX = dateToPxExport(event.date);
                const boxWidth = 180;
                const startX = eventX - boxWidth / 2;
                const endX = eventX + boxWidth / 2;

                let lowestY = -30;
                for (const segment of skylineUp) {
                    if (Math.max(startX, segment.startX) < Math.min(endX, segment.endX)) {
                        lowestY = Math.min(lowestY, segment.topY);
                    }
                }
                
                let boxHeight = 0;
                if (showDescriptions && (event.description || event.img)) {
                    const titleHeight = 20; const padding = 10; let descHeight = 0; let imgHeight = 0;
                    if (event.description) {
                        const lines = wrapText(tempCtx, event.description, boxWidth - padding * 2);
                        event.descriptionLines = lines;
                        const fontSize = getDynamicFontSize(lines.length);
                        const lineHeight = fontSize * 1.2;
                        descHeight = lines.length * lineHeight;
                    }
                    if (event.img) imgHeight = 50 + (event.description ? padding : 0);
                    boxHeight = titleHeight + descHeight + imgHeight + padding * 2;
                }
                event.height = boxHeight;
                event.y = lowestY - (boxHeight > 0 ? boxHeight + vSpacing : 0); 
                const newTopY = event.y - vSpacing;
                
                const newSkyline = []; let added = false;
                for (const segment of skylineUp) {
                    if (segment.endX <= startX) newSkyline.push(segment);
                    else {
                        if (!added) { newSkyline.push({ startX: startX, endX: endX, topY: newTopY }); added = true; }
                        if (segment.endX > endX) newSkyline.push({startX: endX, endX: segment.endX, topY: segment.topY});
                    }
                }
                if (!added) newSkyline.push({ startX: startX, endX: endX, topY: newTopY });
                skylineUp.length = 0;
                Array.prototype.push.apply(skylineUp, newSkyline.sort((a, b) => a.startX - b.startX));
                layout.events.push(event);
            });

            const minEventY = layout.events.reduce((min, e) => Math.min(min, e.y), 0);
            const yOffset = topPadding - minEventY;
            const axisY = yOffset;
            layout.events.forEach(e => { e.y += yOffset; });

            const lanesDown = [];
            const sortedPeriods = JSON.parse(JSON.stringify(state.periods)).sort((a, b) => (a.renderOrder || 0) - (b.renderOrder || 0));
            let maxPeriodY = axisY + 30;

            sortedPeriods.forEach(period => {
                const startX = dateToPxExport(period.startDate);
                const endX = dateToPxExport(period.endDate);
                
                const titleHeight = 16; const paddingY = 4; let descriptionHeight = 0; let imageHeight = 0;
                const yearRangeHeight = 10;
                if (showDescriptions && period.description) {
                    const pWidth = endX - startX;
                    const wrapWidth = Math.max(1, pWidth - (paddingY * 2));
                    const lines = wrapText(tempCtx, period.description, wrapWidth);
                    period.descriptionLines = lines;
                    const fontSize = getDynamicFontSize(lines.length);
                    const lineHeight = fontSize * 1.2;
                    descriptionHeight = lines.length * lineHeight;
                }
                if (showDescriptions && period.img) imageHeight = 50 + (period.description ? paddingY : 0);

                period.height = titleHeight + yearRangeHeight + descriptionHeight + imageHeight + (paddingY * 2);

                let assignedLane = -1;
                for (let i = 0; i < lanesDown.length; i++) {
                    if (startX >= lanesDown[i]) {
                        assignedLane = i;
                        break;
                    }
                }

                if (assignedLane === -1) {
                    assignedLane = lanesDown.length;
                    lanesDown.push(0);
                }
                
                period.y = axisY + 30 + (assignedLane * period.height);
                lanesDown[assignedLane] = endX;
                
                maxPeriodY = Math.max(maxPeriodY, period.y + period.height);
                layout.periods.push(period);
            });

            const bottomPadding = 30;
            const totalHeight = maxPeriodY + bottomPadding;

            return { layout, totalHeight: Math.max(150, totalHeight), axisY };
        }


        function updateCalculatedExportHeight() {
            const start = parseFloat(document.getElementById('exportStartDate').value);
            const end = parseFloat(document.getElementById('exportEndDate').value);
            const width = parseInt(document.getElementById('exportWidth').value, 10);
            const showDescriptions = document.getElementById('exportDescriptions').checked;
            if (isNaN(start) || isNaN(end) || isNaN(width) || width <= 0 || start >= end) return;
            const { totalHeight } = getExportLayout(start, end, width, showDescriptions);
            document.getElementById('exportHeight').value = Math.ceil(totalHeight);
        }
        
        ['exportStartDate', 'exportEndDate', 'exportWidth', 'exportDescriptions'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateCalculatedExportHeight);
        });

        async function exportJpeg(start, end, width, height, showDescriptions) {
            if (isNaN(start) || isNaN(end) || isNaN(width) || isNaN(height) || width <= 0 || height <= 0 || start >= end) {
                showConfirm('Vennligst fyll inn gyldige eksportinnstillinger.', () => {}, true); return;
            }
            document.getElementById('exportSpinner').style.display = 'block';
            document.getElementById('generateJpegBtn').disabled = true;

            setTimeout(() => {
                try {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = width; tempCanvas.height = height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = '#f7fafc'; tempCtx.fillRect(0, 0, width, height);
                    
                    const finalHeightLayout = getExportLayout(start, end, width, showDescriptions);

                    drawOnTempCanvas(tempCtx, width, height, finalHeightLayout.layout, finalHeightLayout.axisY, start, end, showDescriptions);
                    
                    const dataUrl = tempCanvas.toDataURL('image/jpeg', 0.9);
                    
                    const dataToExport = getTimelineData();
                    const dataStr = EXPORT_DATA_MARKER + JSON.stringify(dataToExport);
                    const exifObj = {"Exif": {[piexif.ExifIFD.UserComment]: dataStr}};
                    const exifBytes = piexif.dump(exifObj);
                    const dataWithExif = piexif.insert(exifBytes, dataUrl);

                    const a = document.createElement('a');
                    a.href = dataWithExif;
                    a.download = 'tidslinje.jpeg';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                } catch (err) {
                    console.error("Export failed:", err); showConfirm("En feil oppstod under eksporten.", () => {}, true);
                } finally {
                    document.getElementById('exportSpinner').style.display = 'none';
                    document.getElementById('generateJpegBtn').disabled = false;
                    closeModal(exportJpegSettingsModal); closeModal(exportModal);
                }
            }, 50);
        }

        function wrapText(context, text, maxWidth) {
            if (maxWidth <= 0) return [text];
            const words = text.split(' '); let lines = []; let currentLine = words[0] || '';
            for (let i = 1; i < words.length; i++) {
                const word = words[i]; const width = context.measureText(currentLine + " " + word).width;
                if (width < maxWidth) { currentLine += " " + word; } else { lines.push(currentLine); currentLine = word; }
            }
            lines.push(currentLine); return lines;
        }

        function drawOnTempCanvas(tempCtx, width, height, layout, axisY, start, end, showDescriptions) {
            const dateToPxFn = (date) => (date - start) * (width / (end - start));
            
            tempCtx.beginPath(); tempCtx.moveTo(0, axisY); tempCtx.lineTo(width, axisY); tempCtx.strokeStyle = '#4A5568'; tempCtx.lineWidth = 2; tempCtx.stroke();
            
            const tempState = { view: { zoom: width / (end - start), markerDensity: 1 } };
            const tempPxToDate = (px) => (px / tempState.view.zoom) + start;
            
            const interval = getMarkerInterval.call({
                state: tempState, 
                canvas: {width: width / 1, getBoundingClientRect: () => ({left:0})},
                pxToDate: tempPxToDate
            });

            const startYear = Math.floor(tempPxToDate(0) / interval) * interval;
            const endYear = Math.ceil(tempPxToDate(width) / interval) * interval;
            tempCtx.fillStyle = '#4A5568'; tempCtx.textAlign = 'center'; tempCtx.font = '12px Inter';
            for (let year = startYear; year <= endYear; year += interval) {
                const x = dateToPxFn(year);
                if (x < 0 || x > width) continue;
                const tickHeight = year % (interval * 10) === 0 ? 15 : 8;
                tempCtx.beginPath(); tempCtx.moveTo(x, axisY - tickHeight); tempCtx.lineTo(x, axisY + tickHeight);
                tempCtx.strokeStyle = '#4A5568'; tempCtx.lineWidth = year % (interval * 10) === 0 ? 2 : 1; tempCtx.stroke();
                tempCtx.fillText(formatYear(year), x, axisY + tickHeight + 15);
            }
            
            drawEvents(tempCtx, dateToPxFn, layout.events, state.images, axisY, showDescriptions);
            drawPeriods(tempCtx, dateToPxFn, layout.periods, state.images, showDescriptions);
        }


        document.getElementById('generateJpegBtn').addEventListener('click', () => {
            const start = parseFloat(document.getElementById('exportStartDate').value);
            const end = parseFloat(document.getElementById('exportEndDate').value);
            const width = parseInt(document.getElementById('exportWidth').value, 10);
            const height = parseInt(document.getElementById('exportHeight').value, 10);
            const showDescriptions = document.getElementById('exportDescriptions').checked;
            exportJpeg(start, end, width, height, showDescriptions);
        });

        importBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    let importedData;
                    if (file.type === 'image/jpeg' || file.name.toLowerCase().endsWith('.jpeg') || file.name.toLowerCase().endsWith('.jpg')) {
                        const dataUrl = event.target.result;
                        const exifObj = piexif.load(dataUrl);
                        const dataStr = exifObj.Exif[piexif.ExifIFD.UserComment];

                        if (dataStr && dataStr.startsWith(EXPORT_DATA_MARKER)) {
                            const jsonStr = dataStr.substring(EXPORT_DATA_MARKER.length);
                            importedData = JSON.parse(jsonStr);
                        } else {
                            throw new Error('Ingen tidslinjedata funnet i bildet.');
                        }
                    } else {
                        importedData = JSON.parse(event.target.result);
                    }
                    
                    if (importedData.events && importedData.periods) {
                        state.events.push(...importedData.events);
                        state.periods.push(...importedData.periods);
                        [...importedData.events, ...importedData.periods].forEach(loadImage);
                        requestDraw();
                        saveState();
                    } else { throw new Error('Invalid timeline file format.'); }
                } catch (err) {
                    showConfirm('Feil: Kunne ikke importere filen. Den kan være ødelagt eller i feil format. Detaljer: ' + err.message, () => {}, true);
                    console.error(err);
                }
            };
            if (file.type === 'image/jpeg' || file.name.toLowerCase().endsWith('.jpeg') || file.name.toLowerCase().endsWith('.jpg')) {
                 reader.readAsDataURL(file);
            } else {
                 reader.readAsText(file);
            }
            importFileInput.value = '';
        });

        // --- Helper Functions ---
        function formatYear(year, isApproximate = false) {
            const roundedYear = Math.round(year);
            const prefix = isApproximate ? 'ca. ' : '';
            if (roundedYear < 0) {
                return `${prefix}${Math.abs(roundedYear)} fvt.`;
            }
            return `${prefix}${roundedYear}`;
        }
        
        // NEW: Helper to format year with month if needed
        function formatYearWithMonth(date, isApproximate = false) {
            if (state.view.zoom > MONTH_ZOOM_THRESHOLD) {
                const year = Math.floor(date);
                const monthIndex = Math.round((date - year) * 12);
                const month = MONTH_NAMES[monthIndex % 12];
                const finalYear = monthIndex === 12 ? year + 1 : year; // Handle rounding up to next year's Jan
                return `${month} ${formatYear(finalYear, isApproximate)}`;
            }
            return formatYear(date, isApproximate);
        }

        function hexToRgba(hex, alpha) {
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) {
                r = "0x" + hex[1] + hex[1];
                g = "0x" + hex[2] + hex[2];
                b = "0x" + hex[3] + hex[3];
            } else if (hex.length == 7) {
                r = "0x" + hex[1] + hex[2];
                g = "0x" + hex[3] + hex[4];
                b = "0x" + hex[5] + hex[6];
            }
            return `rgba(${+r},${+g},${+b},${alpha})`;
        }

        // --- Initial Setup ---
        function initializeView() {
            const dpr = window.devicePixelRatio || 1;
            const canvasWidth = canvas.width / dpr;
            const totalYears = state.view.end - state.view.start;
            
            state.view.markerDensity = parseFloat(zoomSensitivitySlider.value);

            MIN_ZOOM_LEVEL = canvasWidth / (totalYears * 1.1);
            state.view.zoom = MIN_ZOOM_LEVEL;
            state.view.panX = 0;
            state.view.panY = 0;
            clampPanX();
            updateZoomSlider();
            requestDraw();
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            updateViewForNewRange();
        });
        
        loadState();
        resizeCanvas();
        initializeView();
    });
    </script>
</body>
</html>
