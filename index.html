<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Daniels tidslinje-mekker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Library for reading/writing JPEG metadata -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/piexifjs/1.0.6/piexif.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevents pull-to-refresh on mobile */
        }
        canvas {
            cursor: grab;
        }
        canvas.grabbing {
            cursor: grabbing;
        }
        .modal {
            display: none; /* Hidden by default */
        }
        .modal.active {
            display: flex; /* Show when active */
        }
        /* Custom styles for range slider */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db; /* gray-300 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type=range]:hover {
            opacity: 1;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4f46e5; /* indigo-600 */
            cursor: pointer;
            border-radius: 50%;
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4f46e5; /* indigo-600 */
            cursor: pointer;
            border-radius: 50%;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen overflow-hidden">

    <!-- Header & Controls -->
    <header class="bg-white shadow-md p-2 md:p-4 flex flex-wrap items-center justify-between gap-4 z-10">
        <h1 class="text-xl md:text-2xl font-bold text-gray-700 flex items-center gap-2">
            <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-indigo-600"><path d="M2 12h20"/><path d="M12 2a10 10 0 0 0-10 10v0a10 10 0 0 0 10 10v0a10 10 0 0 0 10-10v0a10 10 0 0 0-10-10v0Z"/><path d="M12 12v-2"/><path d="M12 18v-2"/></svg>
            Daniels tidslinje-mekker
        </h1>
        
        <div class="flex items-center gap-4 flex-wrap">
            <!-- Date Range Controls -->
            <div class="flex items-center gap-2 flex-wrap border-r pr-4">
                <label for="startDate" class="text-sm font-medium">Fra år...</label>
                <input type="number" id="startDate" value="1990" class="w-24 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                <label for="endDate" class="text-sm font-medium">...til år.</label>
                <input type="number" id="endDate" value="2030" class="w-24 p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                <button id="setDateRange" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 text-sm font-semibold">Vis disse årene</button>
            </div>
              <!-- Zoom Sensitivity -->
            <div class="flex items-center gap-2">
                <label for="zoomSensitivity" class="text-sm font-medium">Detaljnivå:</label>
                <input type="range" id="zoomSensitivity" min="0.5" max="5" step="0.1" value="1" class="w-24">
            </div>
             <!-- Show Descriptions Toggle -->
            <div class="flex items-center gap-2 border-l pl-4">
                <label for="showDescriptionsToggle" class="text-sm font-medium cursor-pointer">Vis beskrivelser</label>
                <input type="checkbox" id="showDescriptionsToggle" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500 cursor-pointer">
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex items-center gap-2 flex-wrap">
            <button id="addEventBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 text-sm font-semibold">Legg til hendelse</button>
            <button id="addPeriodBtn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 text-sm font-semibold">Legg til periode</button>
            <button id="exportBtn" class="px-4 py-2 bg-gray-700 text-white rounded-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-600 text-sm font-semibold">Eksporter</button>
            <button id="importBtn" class="px-4 py-2 bg-gray-700 text-white rounded-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-600 text-sm font-semibold">Importer</button>
            <button id="clearAllBtn" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 text-sm font-semibold">Slett alt</button>
            <input type="file" id="importFile" class="hidden" accept=".json,image/jpeg">
        </div>
    </header>

    <!-- Main Content: Canvas -->
    <main class="flex-grow relative">
        <canvas id="timelineCanvas"></canvas>
    </main>

    <!-- Modals -->
    <!-- Details Modal -->
    <div id="detailsModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 items-center justify-center z-30">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg m-4 max-h-[90vh] overflow-y-auto">
            <h2 id="detailsTitle" class="text-2xl font-bold mb-4 text-gray-800"></h2>
            <p id="detailsDesc" class="text-gray-600 mb-4 whitespace-pre-wrap"></p>
            <img id="detailsImg" src="" alt="Image preview" class="hidden max-w-full max-h-[50vh] mx-auto rounded-md mb-4 object-contain" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" >
            <p id="detailsImgError" class="text-center text-red-500 hidden">Bilde kunne ikke lastes.</p>
            <div class="flex justify-between items-center">
                <div>
                    <button type="button" id="editItemBtn" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Rediger</button>
                    <button type="button" id="deleteItemBtn" class="px-4 py-2 ml-2 bg-red-600 text-white rounded-md hover:bg-red-700">Slett</button>
                </div>
                <button type="button" id="closeDetails" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Lukk</button>
            </div>
        </div>
    </div>
    
    <!-- Event Modal -->
    <div id="eventModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 items-center justify-center z-40">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md m-4 max-h-[90vh] overflow-y-auto">
            <h2 id="eventModalTitle" class="text-2xl font-bold mb-4">Legg til ny hendelse</h2>
            <form id="eventForm">
                <input type="hidden" id="eventId">
                <div class="mb-4">
                    <label for="eventDate" class="block text-sm font-medium text-gray-700">Dato (År)</label>
                    <input type="number" step="any" id="eventDate" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="mb-4">
                    <label for="eventTitle" class="block text-sm font-medium text-gray-700">Tittel</label>
                    <input type="text" id="eventTitle" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="mb-4">
                    <label for="eventDesc" class="block text-sm font-medium text-gray-700">Beskrivelse</label>
                    <textarea id="eventDesc" rows="3" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                </div>
                <div class="mb-4">
                    <label for="eventImg" class="block text-sm font-medium text-gray-700">Bilde-URL (Valgfritt)</label>
                    <input type="url" id="eventImg" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="flex justify-end gap-4">
                    <button type="button" id="cancelEvent" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Avbryt</button>
                    <button type="submit" id="saveEventBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">Legg til hendelse</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Period Modal -->
    <div id="periodModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 items-center justify-center z-40">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md m-4 max-h-[90vh] overflow-y-auto">
            <h2 id="periodModalTitle" class="text-2xl font-bold mb-4">Legg til ny periode</h2>
            <form id="periodForm">
                <input type="hidden" id="periodId">
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="periodStartDate" class="block text-sm font-medium text-gray-700">Startdato (År)</label>
                        <input type="number" step="any" id="periodStartDate" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div>
                        <label for="periodEndDate" class="block text-sm font-medium text-gray-700">Sluttdato (År)</label>
                        <input type="number" step="any" id="periodEndDate" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                </div>
                <div class="mb-4">
                    <label for="periodTitle" class="block text-sm font-medium text-gray-700">Tittel</label>
                    <input type="text" id="periodTitle" required class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="mb-4">
                    <label for="periodDesc" class="block text-sm font-medium text-gray-700">Beskrivelse</label>
                    <textarea id="periodDesc" rows="3" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500"></textarea>
                </div>
                <div class="mb-4">
                    <label for="periodImg" class="block text-sm font-medium text-gray-700">Bilde-URL (Valgfritt)</label>
                    <input type="url" id="periodImg" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div class="flex justify-end gap-4">
                    <button type="button" id="cancelPeriod" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Avbryt</button>
                    <button type="submit" id="savePeriodBtn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">Legg til periode</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Export Modal -->
    <div id="exportModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 items-center justify-center z-20">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md m-4 max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-bold mb-4">Eksporter tidslinje</h2>
            <p class="text-gray-600 mb-6">Velg eksportformat.</p>
            <div class="flex flex-col gap-4">
                <button id="exportJsonBtn" class="w-full px-4 py-3 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 font-semibold">Last ned datafil (.json)</button>
                <button id="exportJpegAutoBtn" class="w-full px-4 py-3 bg-teal-500 text-white rounded-md hover:bg-teal-600 font-semibold">Last ned bilde (Auto)</button>
                <button id="exportJpegSettingsBtn" class="w-full px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 font-semibold text-sm">Manuelle innstillinger for bilde...</button>
            </div>
             <div class="mt-6 text-right">
                <button type="button" id="cancelExport" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Lukk</button>
            </div>
        </div>
    </div>

    <!-- Export JPEG Settings Modal -->
    <div id="exportJpegSettingsModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 items-center justify-center z-30">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-lg m-4 max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-bold mb-4">Innstillinger for bildeeksport</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="exportStartDate" class="block text-sm font-medium text-gray-700">Startår</label>
                    <input type="number" id="exportStartDate" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div>
                    <label for="exportEndDate" class="block text-sm font-medium text-gray-700">Sluttår</label>
                    <input type="number" id="exportEndDate" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div>
                    <label for="exportWidth" class="block text-sm font-medium text-gray-700">Bredde (piksler)</label>
                    <input type="number" id="exportWidth" value="1920" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                </div>
                <div>
                    <label for="exportHeight" class="block text-sm font-medium text-gray-700">Høyde (piksler)</label>
                    <input type="number" id="exportHeight" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm">
                    <p class="text-xs text-gray-500 mt-1">Automatisk beregnet. Kan overstyres.</p>
                </div>
            </div>
            <div class="mb-4">
                <label class="flex items-center">
                    <input type="checkbox" id="exportDescriptions" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                    <span class="ml-2 text-sm text-gray-700">Vis beskrivelser</span>
                </label>
            </div>
            <div id="exportSpinner" class="hidden my-4 text-center">
                <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                <p class="text-sm text-gray-600">Genererer bilde...</p>
            </div>
            <div class="flex justify-end gap-4 mt-6">
                <button type="button" id="cancelExportJpeg" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Avbryt</button>
                <button type="button" id="generateJpegBtn" class="px-4 py-2 bg-teal-500 text-white rounded-md hover:bg-teal-600 font-semibold">Generer og last ned</button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm m-4">
            <h2 id="confirmTitle" class="text-lg font-bold mb-4">Er du sikker?</h2>
            <p id="confirmText" class="text-gray-600 mb-6">Denne handlingen kan ikke angres.</p>
            <div class="flex justify-end gap-4">
                <button type="button" id="confirmCancel" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300">Avbryt</button>
                <button type="button" id="confirmOk" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700">Slett</button>
            </div>
        </div>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const canvas = document.getElementById('timelineCanvas');
        const ctx = canvas.getContext('2d');
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');
        const setDateRangeBtn = document.getElementById('setDateRange');
        const zoomSensitivitySlider = document.getElementById('zoomSensitivity');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const showDescriptionsToggle = document.getElementById('showDescriptionsToggle');
        
        // Modals
        const detailsModal = document.getElementById('detailsModal');
        const eventModal = document.getElementById('eventModal');
        const periodModal = document.getElementById('periodModal');
        const exportModal = document.getElementById('exportModal');
        const exportJpegSettingsModal = document.getElementById('exportJpegSettingsModal');
        const confirmModal = document.getElementById('confirmModal');

        // Buttons
        const addEventBtn = document.getElementById('addEventBtn');
        const addPeriodBtn = document.getElementById('addPeriodBtn');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const importFileInput = document.getElementById('importFile');
        
        // --- State Management ---
        let state = {
            timelineStart: 1990,
            timelineEnd: 2030,
            events: [],
            periods: [],
            view: {
                zoom: 1, // pixels per year
                panX: 0,
                panY: 0,
                markerDensity: 1,
                showDescriptions: false,
            },
            images: {}, // Cache for loaded images
            dragging: {
                isDown: false,
                startX: 0,
                startY: 0,
                scrollLeft: 0,
                scrollTop: 0,
                activeItem: null, // Can be an event or a period
                dragType: null, // 'move', 'resize-left', 'resize-right', 'pan', 'create'
                creationRect: null, // For drag-to-create-period
            },
            mouse: {
                x: 0,
                y: 0,
                isOverItem: false,
            },
            editingItemId: null,
            editingItemType: null,
        };

        // --- Local Storage Management ---
        const LOCAL_STORAGE_KEY = 'timelineData';
        const saveState = () => {
            const dataToSave = {
                timelineStart: state.timelineStart,
                timelineEnd: state.timelineEnd,
                events: state.events.map(({lane, y, ...rest}) => rest),
                periods: state.periods.map(({lane, y, ...rest}) => rest),
            };
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
            console.log('Tidslinje lagret automatisk.');
        };

        const loadState = () => {
            const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    state.timelineStart = parsedData.timelineStart;
                    state.timelineEnd = parsedData.timelineEnd;
                    state.events = parsedData.events;
                    state.periods = parsedData.periods;
                    
                    startDateInput.value = state.timelineStart;
                    endDateInput.value = state.timelineEnd;
                    
                    [...state.events, ...state.periods].forEach(loadImage);
                    
                    console.log('Tidslinje lastet fra lagring.');
                    return true;
                } catch (e) {
                    console.error("Feil ved lasting av lagret data:", e);
                    localStorage.removeItem(LOCAL_STORAGE_KEY);
                    return false;
                }
            }
            return false;
        };

        // --- Canvas & Drawing Setup ---
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth * window.devicePixelRatio;
            canvas.height = canvas.parentElement.clientHeight * window.devicePixelRatio;
            canvas.style.width = `${canvas.parentElement.clientWidth}px`;
            canvas.style.height = `${canvas.parentElement.clientHeight}px`;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            requestDraw();
        }

        // --- Coordinate Conversion ---
        const dateToPx = (date) => (date - state.timelineStart) * state.view.zoom + state.view.panX;
        const pxToDate = (px) => (px - state.view.panX) / state.view.zoom + state.timelineStart;

        // --- Layout & Drawing ---
        let drawQueued = false;
        function requestDraw() {
            if (!drawQueued) {
                drawQueued = true;
                requestAnimationFrame(() => {
                    const dpr = window.devicePixelRatio || 1;
                    const viewHeight = canvas.height / dpr;
                    calculateLayout(dateToPx, viewHeight, state.view.panY);
                    draw();
                    drawQueued = false;
                });
            }
        }
        
        function calculateLayout(coordFn, viewHeight, panY, context = ctx) {
            const eventLaneHeight = state.view.showDescriptions ? 100 : 50;
            const periodLaneHeight = state.view.showDescriptions ? 110 : 55;
            const labelPadding = 20;

            context.font = 'bold 14px Inter';
            const sortedEvents = [...state.events].sort((a, b) => a.date - b.date);
            const sortedPeriods = [...state.periods].sort((a, b) => a.startDate - b.startDate);

            const eventLanes = [];
            sortedEvents.forEach(event => {
                const eventX = coordFn(event.date);
                const textWidth = context.measureText(event.title).width;
                const labelStartX = eventX - textWidth / 2;
                let placed = false;
                for (let i = 0; i < eventLanes.length; i++) {
                    if (labelStartX > eventLanes[i] + labelPadding) {
                        event.lane = i;
                        eventLanes[i] = labelStartX + textWidth;
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    event.lane = eventLanes.length;
                    eventLanes.push(labelStartX + textWidth);
                }
                event.y = (viewHeight / 2) + panY - 30 - (event.lane * eventLaneHeight);
            });

            const periodLanes = [];
            sortedPeriods.forEach(period => {
                const startX = coordFn(period.startDate);
                const endX = coordFn(period.endDate);
                let placed = false;
                for (let i = 0; i < periodLanes.length; i++) {
                    if (startX > periodLanes[i] + labelPadding) {
                        period.lane = i;
                        periodLanes[i] = endX;
                        placed = true;
                        break;
                    }
                }
                if (!placed) {
                    period.lane = periodLanes.length;
                    periodLanes.push(endX);
                }
                period.y = (viewHeight / 2) + panY + 30 + (period.lane * periodLaneHeight);
            });
            return { eventLanes: eventLanes.length, periodLanes: periodLanes.length };
        }

        function draw() {
            const dpr = window.devicePixelRatio;
            const { width, height } = canvas;
            ctx.clearRect(0, 0, width / dpr, height / dpr);

            const axisY = (height / dpr / 2) + state.view.panY;
            ctx.beginPath();
            ctx.moveTo(0, axisY);
            ctx.lineTo(width / dpr, axisY);
            ctx.strokeStyle = '#4A5568';
            ctx.lineWidth = 2;
            ctx.stroke();

            drawMarkers(axisY);
            drawPeriods(axisY);
            drawEvents(axisY);
            drawCreationRect();
            drawHoverIndicator();
        }

        function drawHoverIndicator() {
            if (state.dragging.isDown || state.mouse.isOverItem) return;
            const axisY = (canvas.height / window.devicePixelRatio / 2) + state.view.panY;
            const x = state.mouse.x;
            const y = axisY - 30;

            ctx.globalAlpha = 0.5;
            ctx.beginPath(); ctx.moveTo(x, axisY); ctx.lineTo(x, y); ctx.strokeStyle = '#A0AEC0'; ctx.lineWidth = 2; ctx.stroke();
            ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI * 2); ctx.fillStyle = '#A0AEC0'; ctx.fill();
            ctx.globalAlpha = 1.0;
        }

        function drawCreationRect() {
            if (!state.dragging.creationRect) return;
            const rect = state.dragging.creationRect;
            const x = Math.min(rect.startX, rect.endX);
            const width = Math.abs(rect.endX - rect.startX);
            const axisY = (canvas.height / window.devicePixelRatio / 2) + state.view.panY;
            
            ctx.fillStyle = 'rgba(66, 153, 225, 0.3)';
            ctx.strokeStyle = 'rgba(43, 108, 176, 0.8)';
            ctx.lineWidth = 1;
            ctx.fillRect(x, axisY + 30, width, 40);
            ctx.strokeRect(x, axisY + 30, width, 40);
        }

        function getMarkerInterval() {
            const yearsOnScreen = (canvas.width / window.devicePixelRatio) / state.view.zoom;
            const adjustedYears = yearsOnScreen / state.view.markerDensity;
            if (adjustedYears > 5000) return 1000;
            if (adjustedYears > 2000) return 500;
            if (adjustedYears > 1000) return 200;
            if (adjustedYears > 500) return 100;
            if (adjustedYears > 200) return 50;
            if (adjustedYears > 100) return 20;
            if (adjustedYears > 50) return 10;
            if (adjustedYears > 20) return 5;
            if (adjustedYears > 10) return 2;
            return 1;
        }

        function drawMarkers(axisY) {
            const interval = getMarkerInterval();
            const startYear = Math.floor(pxToDate(0) / interval) * interval;
            const endYear = Math.ceil(pxToDate(canvas.width / window.devicePixelRatio) / interval) * interval;

            ctx.fillStyle = '#4A5568'; ctx.textAlign = 'center'; ctx.font = '12px Inter';

            for (let year = startYear; year <= endYear; year += interval) {
                const x = dateToPx(year);
                if (x < 0 || x > canvas.width / window.devicePixelRatio) continue;
                const isMajor = year % (interval * 10) === 0;
                const tickHeight = isMajor ? 15 : 8;
                ctx.beginPath(); ctx.moveTo(x, axisY - tickHeight); ctx.lineTo(x, axisY + tickHeight);
                ctx.strokeStyle = '#4A5568'; ctx.lineWidth = isMajor ? 2 : 1; ctx.stroke();
                if (isMajor || state.view.zoom > (5 / state.view.markerDensity)) {
                    ctx.fillText(year, x, axisY + tickHeight + 15);
                }
            }
        }

        function drawEvents(axisY) {
            state.events.forEach(event => {
                const x = dateToPx(event.date);
                ctx.beginPath(); ctx.moveTo(x, axisY); ctx.lineTo(x, event.y); ctx.strokeStyle = '#38A169'; ctx.lineWidth = 2; ctx.stroke();
                ctx.beginPath(); ctx.arc(x, event.y, 6, 0, Math.PI * 2); ctx.fillStyle = '#38A169'; ctx.fill();
                ctx.fillStyle = '#2D3748'; ctx.font = 'bold 14px Inter'; ctx.textAlign = 'center'; ctx.fillText(event.title, x, event.y - 15);

                if (state.view.showDescriptions && event.description) {
                    ctx.font = '12px Inter';
                    ctx.fillStyle = '#4A5568';
                    ctx.textAlign = 'center';
                    const lines = wrapText(ctx, event.description, 180);
                    lines.forEach((line, i) => {
                        ctx.fillText(line, x, event.y + 15 + (i * 14));
                    });
                }
            });
        }
        
        function drawPeriods(axisY) {
            const periodHeight = 40;
            state.periods.forEach(period => {
                const startX = dateToPx(period.startDate);
                const endX = dateToPx(period.endDate);
                const width = endX - startX;

                ctx.fillStyle = 'rgba(66, 153, 225, 0.7)'; ctx.strokeStyle = '#2B6CB0'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.roundRect(startX, period.y, width, periodHeight, 8); ctx.fill(); ctx.stroke();

                ctx.fillStyle = 'white'; ctx.font = 'bold 14px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                
                const textFits = ctx.measureText(period.title).width < width - 10;
                if (state.view.zoom > 0.5 && textFits) {
                    ctx.save(); ctx.beginPath(); ctx.rect(startX, period.y, width, periodHeight); ctx.clip();
                    ctx.fillText(period.title, startX + width / 2, period.y + periodHeight / 2); ctx.restore();
                } else {
                    ctx.fillStyle = '#2B6CB0';
                    ctx.fillText(period.title, startX + width / 2, period.y - 10);
                }

                if (state.view.showDescriptions && period.description) {
                    ctx.font = '12px Inter';
                    ctx.fillStyle = '#4A5568';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'alphabetic';
                    const lines = wrapText(ctx, period.description, width - 20);
                    lines.forEach((line, i) => {
                        ctx.fillText(line, startX + width / 2, period.y + 40 + 15 + (i * 14));
                    });
                }
            });
        }
        
        // --- Image Loading ---
        function loadImage(item) {
            if (item.img && !state.images[item.img]) {
                const image = new Image();
                image.src = item.img;
                image.onload = () => { state.images[item.img] = image; requestDraw(); };
                image.onerror = () => { console.error(`Failed to load image: ${item.img}`); state.images[item.img] = null; }
            }
        }

        // --- Event Handlers ---
        setDateRangeBtn.addEventListener('click', () => {
            const start = parseInt(startDateInput.value, 10);
            const end = parseInt(endDateInput.value, 10);
            if (!isNaN(start) && !isNaN(end) && start < end) {
                state.timelineStart = start;
                state.timelineEnd = end;
                const totalYears = state.timelineEnd - state.timelineStart;
                state.view.zoom = (canvas.width / window.devicePixelRatio) / totalYears;
                state.view.panX = 0; state.view.panY = 0; requestDraw();
                saveState();
            } else {
                showConfirm('Vennligst skriv inn et gyldig start- og sluttår, der start er mindre enn slutt.', () => {});
            }
        });

        zoomSensitivitySlider.addEventListener('input', (e) => {
            state.view.markerDensity = parseFloat(e.target.value);
            requestDraw();
        });

        showDescriptionsToggle.addEventListener('change', (e) => {
            state.view.showDescriptions = e.target.checked;
            document.getElementById('exportDescriptions').checked = e.target.checked;
            requestDraw();
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const zoomFactor = 1.1;
            const dateAtMouse = pxToDate(mouseX);
            if (e.deltaY < 0) { state.view.zoom *= zoomFactor; } else { state.view.zoom /= zoomFactor; }
            state.view.panX = mouseX - (dateAtMouse - state.timelineStart) * state.view.zoom;
            requestDraw();
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            state.dragging.isDown = true;
            state.dragging.startX = e.clientX;
            state.dragging.startY = e.clientY;
            state.dragging.scrollLeft = state.view.panX;
            state.dragging.scrollTop = state.view.panY;

            const item = getPeriodAt(mouseX, mouseY) || getEventAt(mouseX, mouseY);
            const axisY = (canvas.height / window.devicePixelRatio / 2) + state.view.panY;
            const distFromAxis = Math.abs(mouseY - axisY);
            const actionZoneThreshold = 50; // pixels from axis to allow creation

            if (item) {
                state.dragging.activeItem = item;
                if (item.type === 'period') {
                    const startPx = dateToPx(item.item.startDate);
                    const endPx = dateToPx(item.item.endDate);
                    const handleSize = 10;
                    if (mouseX > endPx - handleSize) { state.dragging.dragType = 'resize-right'; } 
                    else if (mouseX < startPx + handleSize) { state.dragging.dragType = 'resize-left'; } 
                    else { state.dragging.dragType = 'move'; }
                } else {
                    state.dragging.dragType = 'move';
                }
            } else if (distFromAxis < actionZoneThreshold) {
                state.dragging.dragType = 'create';
                state.dragging.creationRect = { startX: mouseX, endX: mouseX };
            } else {
                state.dragging.dragType = 'pan';
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (!state.dragging.isDown) return;

            const dragDistance = Math.sqrt(Math.pow(e.clientX - state.dragging.startX, 2) + Math.pow(e.clientY - state.dragging.startY, 2));
            state.dragging.isDown = false;
            canvas.classList.remove('grabbing');

            if (dragDistance < 5) { // It's a click
                if (state.dragging.activeItem) {
                    showDetails(state.dragging.activeItem.item, state.dragging.activeItem.type);
                } else if (state.dragging.dragType === 'create') {
                    const clickedDate = pxToDate(state.dragging.creationRect.startX);
                    openEventModal(null, clickedDate);
                }
            } else { // It's a drag
                if (state.dragging.dragType === 'create' && state.dragging.creationRect) {
                    const rect = state.dragging.creationRect;
                    const startDate = pxToDate(Math.min(rect.startX, rect.endX));
                    const endDate = pxToDate(Math.max(rect.startX, rect.endX));
                    openPeriodModal(null, { startDate, endDate });
                }
            }

            state.dragging.activeItem = null;
            state.dragging.creationRect = null;
            state.dragging.dragType = null;
            requestDraw();
            saveState();
        });

        canvas.addEventListener('mouseleave', () => {
            state.mouse.x = -1; state.mouse.y = -1;
            if (state.dragging.isDown) {
                state.dragging.isDown = false;
                state.dragging.creationRect = null;
                state.dragging.dragType = null;
                canvas.classList.remove('grabbing');
                canvas.style.cursor = 'grab';
                saveState();
            }
            requestDraw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            state.mouse.x = mouseX;
            state.mouse.y = mouseY;

            if (state.dragging.isDown) {
                canvas.classList.add('grabbing');
                const dx = e.clientX - state.dragging.startX;
                const dy = e.clientY - state.dragging.startY;

                if (state.dragging.activeItem) {
                    const item = state.dragging.activeItem.item;
                    const type = state.dragging.activeItem.type;
                    const dateChange = dx / state.view.zoom;

                    if (state.dragging.dragType === 'move') {
                        if (type === 'event') { item.date += dateChange; } 
                        else { item.startDate += dateChange; item.endDate += dateChange; }
                    } else if (type === 'period') {
                        if (state.dragging.dragType === 'resize-right') { item.endDate = Math.max(item.startDate + 0.1, pxToDate(mouseX)); } 
                        else if (state.dragging.dragType === 'resize-left') { item.startDate = Math.min(item.endDate - 0.1, pxToDate(mouseX)); }
                    }
                    state.dragging.startX = e.clientX;
                    state.dragging.startY = e.clientY;
                } else if (state.dragging.dragType === 'create') {
                    state.dragging.creationRect.endX = mouseX;
                } else if (state.dragging.dragType === 'pan') {
                    state.view.panX = state.dragging.scrollLeft + dx;
                    state.view.panY = state.dragging.scrollTop + dy;
                }
            } else {
                const item = getPeriodAt(mouseX, mouseY) || getEventAt(mouseX, mouseY);
                state.mouse.isOverItem = !!item;
                if (item) {
                    if (item.type === 'period') {
                        const startPx = dateToPx(item.item.startDate);
                        const endPx = dateToPx(item.item.endDate);
                        if (mouseX > endPx - 10 || mouseX < startPx + 10) { canvas.style.cursor = 'ew-resize'; } 
                        else { canvas.style.cursor = 'move'; }
                    } else {
                        canvas.style.cursor = 'move';
                    }
                } else {
                    const axisY = (canvas.height / window.devicePixelRatio / 2) + state.view.panY;
                    const distFromAxis = Math.abs(mouseY - axisY);
                    const actionZoneThreshold = 50;
                    if (distFromAxis < actionZoneThreshold) {
                        canvas.style.cursor = 'crosshair';
                    } else {
                        canvas.style.cursor = 'grab';
                    }
                }
            }
            requestDraw();
        });
        
        function getEventAt(x, y) {
            const clickRadius = 10;
            for (let i = state.events.length - 1; i >= 0; i--) {
                const event = state.events[i];
                const eventX = dateToPx(event.date);
                const dist = Math.sqrt(Math.pow(x - eventX, 2) + Math.pow(y - event.y, 2));
                if (dist <= clickRadius) return { item: event, index: i, type: 'event' };
            }
            return null;
        }

        function getPeriodAt(x, y) {
            const periodHeight = 40;
            for (let i = state.periods.length - 1; i >= 0; i--) {
                const period = state.periods[i];
                const startX = dateToPx(period.startDate);
                const endX = dateToPx(period.endDate);
                if (x >= startX && x <= endX && y >= period.y && y <= period.y + periodHeight) {
                    return { item: period, index: i, type: 'period' };
                }
            }
            return null;
        }

        // --- Modal Logic ---
        function openModal(modal) { modal.classList.add('active'); }
        function closeModal(modal) { modal.classList.remove('active'); }

        function showDetails(item, type) {
            state.editingItemId = item.id;
            state.editingItemType = type;
            document.getElementById('detailsTitle').textContent = item.title;
            document.getElementById('detailsDesc').textContent = item.description || 'Ingen beskrivelse.';
            const imgEl = document.getElementById('detailsImg');
            const imgErrorEl = document.getElementById('detailsImgError');
            if (item.img) {
                imgEl.src = item.img;
                imgEl.style.display = 'block';
                imgErrorEl.style.display = 'none';
            } else {
                imgEl.style.display = 'none';
                imgErrorEl.style.display = 'none';
            }
            openModal(detailsModal);
        }
        
        // Modal Button Listeners
        document.getElementById('closeDetails').addEventListener('click', () => closeModal(detailsModal));
        document.getElementById('cancelEvent').addEventListener('click', () => closeModal(eventModal));
        document.getElementById('cancelPeriod').addEventListener('click', () => closeModal(periodModal));
        document.getElementById('cancelExport').addEventListener('click', () => closeModal(exportModal));
        document.getElementById('cancelExportJpeg').addEventListener('click', () => closeModal(exportJpegSettingsModal));

        document.getElementById('editItemBtn').addEventListener('click', () => {
            const id = state.editingItemId;
            const type = state.editingItemType;
            if (!id || !type) return;
            if (type === 'event') {
                const event = state.events.find(e => e.id === id);
                openEventModal(event);
            } else if (type === 'period') {
                const period = state.periods.find(p => p.id === id);
                openPeriodModal(period);
            }
            closeModal(detailsModal);
        });

        document.getElementById('deleteItemBtn').addEventListener('click', () => {
            showConfirm('Er du sikker på at du vil slette dette elementet?', () => {
                const id = state.editingItemId;
                const type = state.editingItemType;
                if (type === 'event') { state.events = state.events.filter(e => e.id !== id); } 
                else if (type === 'period') { state.periods = state.periods.filter(p => p.id !== id); }
                closeModal(detailsModal);
                requestDraw();
                saveState();
            });
        });

        clearAllBtn.addEventListener('click', () => {
            showConfirm('Er du sikker på at du vil slette ALLE hendelser og perioder? Denne handlingen kan ikke angres.', () => {
                state.events = [];
                state.periods = [];
                requestDraw();
                saveState();
            });
        });

        function showConfirm(message, onConfirm) {
            document.getElementById('confirmText').textContent = message;
            document.getElementById('confirmTitle').textContent = 'Er du sikker?';
            openModal(confirmModal);
            const confirmOk = document.getElementById('confirmOk');
            const confirmCancel = document.getElementById('confirmCancel');
            const okListener = () => { onConfirm(); closeModal(confirmModal); cleanup(); };
            const cancelListener = () => { closeModal(confirmModal); cleanup(); };
            const cleanup = () => {
                confirmOk.removeEventListener('click', okListener);
                confirmCancel.removeEventListener('click', cancelListener);
            };
            confirmOk.addEventListener('click', okListener, { once: true });
            confirmCancel.addEventListener('click', cancelListener, { once: true });
        }

        function openEventModal(event = null, date = null) {
            document.getElementById('eventForm').reset();
            if (event) { // Editing
                document.getElementById('eventModalTitle').textContent = 'Rediger hendelse';
                document.getElementById('saveEventBtn').textContent = 'Lagre endringer';
                document.getElementById('eventId').value = event.id;
                document.getElementById('eventDate').value = event.date;
                document.getElementById('eventTitle').value = event.title;
                document.getElementById('eventDesc').value = event.description;
                document.getElementById('eventImg').value = event.img;
            } else { // Creating new
                document.getElementById('eventModalTitle').textContent = 'Legg til ny hendelse';
                document.getElementById('saveEventBtn').textContent = 'Legg til hendelse';
                document.getElementById('eventId').value = '';
                if (date) document.getElementById('eventDate').value = parseFloat(date.toFixed(2));
            }
            openModal(eventModal);
        }

        function openPeriodModal(period = null, dates = null) {
            document.getElementById('periodForm').reset();
            if (period) { // Editing
                document.getElementById('periodModalTitle').textContent = 'Rediger periode';
                document.getElementById('savePeriodBtn').textContent = 'Lagre endringer';
                document.getElementById('periodId').value = period.id;
                document.getElementById('periodStartDate').value = period.startDate;
                document.getElementById('periodEndDate').value = period.endDate;
                document.getElementById('periodTitle').value = period.title;
                document.getElementById('periodDesc').value = period.description;
                document.getElementById('periodImg').value = period.img;
            } else { // Creating new
                document.getElementById('periodModalTitle').textContent = 'Legg til ny periode';
                document.getElementById('savePeriodBtn').textContent = 'Legg til periode';
                document.getElementById('periodId').value = '';
                if (dates) {
                    document.getElementById('periodStartDate').value = parseFloat(dates.startDate.toFixed(2));
                    document.getElementById('periodEndDate').value = parseFloat(dates.endDate.toFixed(2));
                }
            }
            openModal(periodModal);
        }

        addEventBtn.addEventListener('click', () => openEventModal());
        addPeriodBtn.addEventListener('click', () => openPeriodModal());

        document.getElementById('eventForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const eventId = document.getElementById('eventId').value;
            const data = {
                date: parseFloat(document.getElementById('eventDate').value),
                title: document.getElementById('eventTitle').value,
                description: document.getElementById('eventDesc').value,
                img: document.getElementById('eventImg').value,
            };
            if (eventId) {
                const index = state.events.findIndex(ev => ev.id == eventId);
                if (index !== -1) state.events[index] = { ...state.events[index], ...data };
            } else {
                data.id = Date.now();
                state.events.push(data);
            }
            loadImage(data); requestDraw(); e.target.reset(); closeModal(eventModal);
            saveState();
        });

        document.getElementById('periodForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const periodId = document.getElementById('periodId').value;
            const data = {
                startDate: parseFloat(document.getElementById('periodStartDate').value),
                endDate: parseFloat(document.getElementById('periodEndDate').value),
                title: document.getElementById('periodTitle').value,
                description: document.getElementById('periodDesc').value,
                img: document.getElementById('periodImg').value,
            };
            if (data.startDate >= data.endDate) { showConfirm('Startdato må være før sluttdato.', () => {}); return; }
            if (periodId) {
                const index = state.periods.findIndex(p => p.id == periodId);
                if (index !== -1) state.periods[index] = { ...state.periods[index], ...data };
            } else {
                data.id = Date.now();
                state.periods.push(data);
            }
            loadImage(data); requestDraw(); e.target.reset(); closeModal(periodModal);
            saveState();
        });

        // --- Import/Export Logic ---
        const EXPORT_DATA_MARKER = 'TIMELINE_DATA_JSON=';
        
        function getTimelineData() {
            return {
                timelineStart: state.timelineStart,
                timelineEnd: state.timelineEnd,
                events: state.events.map(({lane, y, ...rest}) => rest),
                periods: state.periods.map(({lane, y, ...rest}) => rest),
            };
        }

        exportBtn.addEventListener('click', () => openModal(exportModal));
        document.getElementById('exportJsonBtn').addEventListener('click', () => {
            const dataToExport = getTimelineData();
            const dataStr = JSON.stringify(dataToExport, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'tidslinje.json';
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            closeModal(exportModal);
        });
        
        function getTimelineBounds() {
            if (state.events.length === 0 && state.periods.length === 0) {
                return { min: state.timelineStart, max: state.timelineEnd };
            }
            const eventDates = state.events.map(e => e.date);
            const periodStartDates = state.periods.map(p => p.startDate);
            const periodEndDates = state.periods.map(p => p.endDate);
            const allDates = [...eventDates, ...periodStartDates, ...periodEndDates];
            const min = Math.min(...allDates);
            const max = Math.max(...allDates);
            const margin = (max - min) * 0.05 || 1;
            return { min: min - margin, max: max + margin };
        }

        document.getElementById('exportJpegAutoBtn').addEventListener('click', () => {
            const bounds = getTimelineBounds();
            const width = 1920;
            const showDescriptions = state.view.showDescriptions;
            const height = calculateExportHeight(bounds.min, bounds.max, width, showDescriptions);
            exportJpeg(bounds.min, bounds.max, width, height, showDescriptions);
            closeModal(exportModal);
        });
        
        document.getElementById('exportJpegSettingsBtn').addEventListener('click', () => {
            const bounds = getTimelineBounds();
            document.getElementById('exportStartDate').value = Math.floor(bounds.min);
            document.getElementById('exportEndDate').value = Math.ceil(bounds.max);
            document.getElementById('exportWidth').value = 1920;
            document.getElementById('exportDescriptions').checked = state.view.showDescriptions;
            updateCalculatedExportHeight();
            openModal(exportJpegSettingsModal);
        });

        function calculateExportHeight(start, end, width, showDescriptions) {
            if (isNaN(start) || isNaN(end) || isNaN(width) || width <= 0 || start >= end) return 400;

            const eventLaneHeight = showDescriptions ? 100 : 50;
            const periodLaneHeight = showDescriptions ? 110 : 55;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            
            const exportZoom = width / (end - start);
            const dateToPxExport = (date) => (date - start) * exportZoom;

            const originalShowDescriptions = state.view.showDescriptions;
            state.view.showDescriptions = showDescriptions;
            
            const { eventLanes, periodLanes } = calculateLayout(dateToPxExport, 1000, 0, tempCtx);

            state.view.showDescriptions = originalShowDescriptions;

            const topSpace = (eventLanes * eventLaneHeight) + 30;
            const bottomSpace = (periodLanes * periodLaneHeight) + 30;
            const axisLabelsHeight = 30;

            const totalHeight = topSpace + bottomSpace + axisLabelsHeight;
            
            return Math.max(400, Math.ceil(totalHeight));
        }

        function updateCalculatedExportHeight() {
            const start = parseFloat(document.getElementById('exportStartDate').value);
            const end = parseFloat(document.getElementById('exportEndDate').value);
            const width = parseInt(document.getElementById('exportWidth').value, 10);
            const showDescriptions = document.getElementById('exportDescriptions').checked;
            document.getElementById('exportHeight').value = calculateExportHeight(start, end, width, showDescriptions);
        }
        
        ['exportStartDate', 'exportEndDate', 'exportWidth', 'exportDescriptions'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateCalculatedExportHeight);
        });

        async function exportJpeg(start, end, width, height, showDescriptions) {
            if (isNaN(start) || isNaN(end) || isNaN(width) || isNaN(height) || width <= 0 || height <= 0 || start >= end) {
                showConfirm('Vennligst fyll inn gyldige eksportinnstillinger.', () => {}); return;
            }
            document.getElementById('exportSpinner').style.display = 'block';
            document.getElementById('generateJpegBtn').disabled = true;

            setTimeout(() => {
                try {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = width; tempCanvas.height = height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.fillStyle = '#f7fafc'; tempCtx.fillRect(0, 0, width, height);
                    const exportZoom = width / (end - start);
                    const dateToPxExport = (date) => (date - start) * exportZoom;
                    
                    const originalShowDescriptions = state.view.showDescriptions;
                    state.view.showDescriptions = showDescriptions;
                    calculateLayout(dateToPxExport, height, 0, tempCtx);
                    state.view.showDescriptions = originalShowDescriptions;

                    drawOnTempCanvas(tempCtx, width, height, dateToPxExport, showDescriptions, start, end);
                    
                    const dataUrl = tempCanvas.toDataURL('image/jpeg', 0.9);
                    
                    const dataToExport = getTimelineData();
                    const dataStr = EXPORT_DATA_MARKER + JSON.stringify(dataToExport);
                    const exifObj = {"Exif": {[piexif.ExifIFD.UserComment]: dataStr}};
                    const exifBytes = piexif.dump(exifObj);
                    const dataWithExif = piexif.insert(exifBytes, dataUrl);

                    const a = document.createElement('a');
                    a.href = dataWithExif;
                    a.download = 'tidslinje.jpeg';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                } catch (err) {
                    console.error("Export failed:", err); showConfirm("En feil oppstod under eksporten.", () => {});
                } finally {
                    document.getElementById('exportSpinner').style.display = 'none';
                    document.getElementById('generateJpegBtn').disabled = false;
                    closeModal(exportJpegSettingsModal); closeModal(exportModal);
                }
            }, 50);
        }

        function wrapText(context, text, maxWidth) {
            const words = text.split(' '); let lines = []; let currentLine = words[0];
            for (let i = 1; i < words.length; i++) {
                const word = words[i]; const width = context.measureText(currentLine + " " + word).width;
                if (width < maxWidth) { currentLine += " " + word; } else { lines.push(currentLine); currentLine = word; }
            }
            lines.push(currentLine); return lines;
        }

        function drawOnTempCanvas(tempCtx, width, height, dateToPxFn, showDesc, start, end) {
            const axisY = height / 2;
            tempCtx.beginPath(); tempCtx.moveTo(0, axisY); tempCtx.lineTo(width, axisY); tempCtx.strokeStyle = '#4A5568'; tempCtx.lineWidth = 2; tempCtx.stroke();
            
            const tempState = { timelineStart: start, timelineEnd: end, view: { zoom: width / (end - start), markerDensity: 1 } };
            const tempPxToDate = (px) => (px / tempState.view.zoom) + tempState.timelineStart;

            const interval = getMarkerInterval.call({state: tempState, canvas: {width: width}});
            const startYear = Math.floor(tempPxToDate(0) / interval) * interval;
            const endYear = Math.ceil(tempPxToDate(width) / interval) * interval;
            tempCtx.fillStyle = '#4A5568'; tempCtx.textAlign = 'center'; tempCtx.font = '12px Inter';
            for (let year = startYear; year <= endYear; year += interval) {
                const x = dateToPxFn(year);
                if (x < 0 || x > width) continue;
                const tickHeight = year % (interval * 10) === 0 ? 15 : 8;
                tempCtx.beginPath(); tempCtx.moveTo(x, axisY - tickHeight); tempCtx.lineTo(x, axisY + tickHeight);
                tempCtx.strokeStyle = '#4A5568'; tempCtx.lineWidth = year % (interval * 10) === 0 ? 2 : 1; tempCtx.stroke();
                tempCtx.fillText(year, x, axisY + tickHeight + 15);
            }
            
            state.events.forEach(event => {
                const x = dateToPxFn(event.date);
                const eventY = event.y;
                
                tempCtx.beginPath(); tempCtx.moveTo(x, axisY); tempCtx.lineTo(x, eventY); tempCtx.strokeStyle = '#38A169'; tempCtx.lineWidth = 2; tempCtx.stroke();
                tempCtx.beginPath(); tempCtx.arc(x, eventY, 6, 0, Math.PI * 2); tempCtx.fillStyle = '#38A169'; tempCtx.fill();
                tempCtx.fillStyle = '#2D3748'; tempCtx.font = 'bold 14px Inter'; tempCtx.textAlign = 'center'; tempCtx.fillText(event.title, x, eventY - 15);
                
                if (showDesc && event.description) {
                    tempCtx.font = '12px Inter'; tempCtx.fillStyle = '#4A5568'; tempCtx.textAlign = 'center';
                    const lines = wrapText(tempCtx, event.description, 200);
                    lines.forEach((line, i) => tempCtx.fillText(line, x, eventY + 15 + (i * 14)));
                    if (event.img && state.images[event.img]) {
                        const img = state.images[event.img];
                        const imgSize = 40;
                        tempCtx.drawImage(img, x - imgSize/2, eventY + 15 + (lines.length * 14) + 5, imgSize, imgSize * img.height / img.width);
                    }
                }
            });

            state.periods.forEach(period => {
                const startX = dateToPxFn(period.startDate); const endX = dateToPxFn(period.endDate); const pWidth = endX - startX;
                const periodY = period.y;
                
                tempCtx.fillStyle = 'rgba(66, 153, 225, 0.7)'; tempCtx.strokeStyle = '#2B6CB0'; tempCtx.lineWidth = 2;
                tempCtx.beginPath(); tempCtx.roundRect(startX, periodY, pWidth, 40, 8); tempCtx.fill(); tempCtx.stroke();
                
                tempCtx.font = 'bold 14px Inter'; tempCtx.textAlign = 'center';
                const textFits = tempCtx.measureText(period.title).width < pWidth - 10;
                if (textFits) {
                    tempCtx.fillStyle = 'white'; tempCtx.textBaseline = 'middle';
                    tempCtx.save(); tempCtx.beginPath(); tempCtx.rect(startX, periodY, pWidth, 40); tempCtx.clip();
                    tempCtx.fillText(period.title, startX + pWidth / 2, periodY + 20); tempCtx.restore();
                } else {
                    tempCtx.fillStyle = '#2B6CB0'; tempCtx.textBaseline = 'alphabetic';
                    tempCtx.fillText(period.title, startX + pWidth / 2, periodY - 10);
                }
                if (showDesc && period.description) {
                    tempCtx.font = '12px Inter'; tempCtx.fillStyle = '#4A5568'; tempCtx.textAlign = 'center';
                    const lines = wrapText(tempCtx, period.description, 200);
                    lines.forEach((line, i) => tempCtx.fillText(line, startX + pWidth / 2, periodY + 40 + 15 + (i * 14)));
                    if (period.img && state.images[period.img]) {
                        const img = state.images[period.img];
                        const imgSize = 40;
                        tempCtx.drawImage(img, startX + pWidth/2 - imgSize/2, periodY + 40 + 15 + (lines.length * 14) + 5, imgSize, imgSize * img.height / img.width);
                    }
                }
            });
        }

        document.getElementById('generateJpegBtn').addEventListener('click', () => {
            const start = parseFloat(document.getElementById('exportStartDate').value);
            const end = parseFloat(document.getElementById('exportEndDate').value);
            const width = parseInt(document.getElementById('exportWidth').value, 10);
            const height = parseInt(document.getElementById('exportHeight').value, 10);
            const showDescriptions = document.getElementById('exportDescriptions').checked;
            exportJpeg(start, end, width, height, showDescriptions);
        });

        importBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    let importedData;
                    if (file.type === 'image/jpeg' || file.name.toLowerCase().endsWith('.jpeg') || file.name.toLowerCase().endsWith('.jpg')) {
                        const dataUrl = event.target.result;
                        const exifObj = piexif.load(dataUrl);
                        const dataStr = exifObj.Exif[piexif.ExifIFD.UserComment];

                        if (dataStr && dataStr.startsWith(EXPORT_DATA_MARKER)) {
                            const jsonStr = dataStr.substring(EXPORT_DATA_MARKER.length);
                            importedData = JSON.parse(jsonStr);
                        } else {
                            throw new Error('Ingen tidslinjedata funnet i bildet.');
                        }
                    } else {
                        importedData = JSON.parse(event.target.result);
                    }
                    
                    if (importedData.events && importedData.periods) {
                        state.events.push(...importedData.events);
                        state.periods.push(...importedData.periods);
                        
                        const bounds = getTimelineBounds();
                        state.timelineStart = Math.floor(bounds.min);
                        state.timelineEnd = Math.ceil(bounds.max);

                        startDateInput.value = state.timelineStart;
                        endDateInput.value = state.timelineEnd;
                        
                        [...importedData.events, ...importedData.periods].forEach(loadImage);
                        
                        const totalYears = state.timelineEnd - state.timelineStart;
                        state.view.zoom = (canvas.width / window.devicePixelRatio) / totalYears;
                        state.view.panX = 0; state.view.panY = 0; 
                        requestDraw();
                        saveState();
                    } else { throw new Error('Invalid timeline file format.'); }
                } catch (err) {
                    showConfirm('Feil: Kunne ikke importere filen. Den kan være ødelagt eller i feil format. Detaljer: ' + err.message, () => {});
                    console.error(err);
                }
            };
            if (file.type === 'image/jpeg' || file.name.toLowerCase().endsWith('.jpeg') || file.name.toLowerCase().endsWith('.jpg')) {
                 reader.readAsDataURL(file);
            } else {
                 reader.readAsText(file);
            }
            importFileInput.value = '';
        });

        // --- Initial Setup ---
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        if (!loadState()) {
            setDateRangeBtn.click();
        }
    });
    </script>
</body>
</html>
